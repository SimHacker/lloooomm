<!DOCTYPE html>
<!-- shneiderman-owls-forest.html -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shneiderman's Owls: Global Forest Observatory (Wizzy Edition)</title>
    <style>
        /* Ben Shneiderman: Overview first, zoom and filter, details on demand */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            /* Prevent text selection globally */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow text selection only in specific areas */
        #stats-panel, .info-panel {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        #visualization {
            position: relative;
            background: radial-gradient(ellipse at center, #001a33 0%, #000511 100%);
            overflow: hidden;
            cursor: crosshair;
            flex: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* Prevent any default drag behavior */
            -webkit-user-drag: none;
            -khtml-user-drag: none;
            -moz-user-drag: none;
            -o-user-drag: none;
            user-drag: none;
            /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #stats-panel {
            background: #1a1a1a;
            overflow-y: auto;
            padding: 20px;
            border-left: 1px solid #333;
            width: 550px;
            box-sizing: border-box;
            position: relative;
            transition: transform 0.3s ease;
            transform: translateX(0);
        }
        
        #stats-panel.collapsed {
            transform: translateX(530px);
        }
        
        #sidebar-tab {
            position: absolute;
            left: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 120px;
            background: #2a2a2a;
            border: 1px solid #333;
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 14px;
            color: #888;
            transition: all 0.3s ease;
        }
        
        #sidebar-tab:hover {
            background: #333;
            color: #aaa;
        }
        
        #panel-toggle {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 40px;
            height: 40px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            z-index: 1000;
            transition: all 0.2s ease;
        }
        
        #panel-toggle:hover {
            background: #3a3a3a;
            border-color: #555;
            transform: scale(1.05);
        }
        
        #stats-panel.panel-hidden {
            transform: translateX(100%);
        }
        
        #panel-toggle.panel-hidden {
            right: -530px;
        }

        h1 {
            font-size: 18px;
            color: #4a9eff;
            margin: 0 0 5px 0;
            margin-right: 50px; /* Add space for console button */
        }

        .subtitle {
            text-align: center;
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
        }

        /* Time display */
        #time-display {
            background: #0a0f1a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        #global-time {
            font-size: 24px;
            font-weight: bold;
            color: #4a9eff;
            font-family: monospace;
        }

        .time-rate {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .help-label {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            line-height: 1.3;
            opacity: 0.8;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background: #2a2a2a;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin-top: 20px;
        }

        .tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            background: #2a2a2a;
            color: #888;
            border: none;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #333;
            color: #aaa;
        }

        .tab.active {
            background: #3a4a5a;
            color: #4a9eff;
            font-weight: bold;
        }

        .tab-content {
            background: #1f1f1f;
            border-radius: 0 0 8px 8px;
            padding: 15px;
            min-height: 400px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        /* Stats table */
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            margin-top: 10px;
            table-layout: fixed;
        }

        .stats-table th {
            background: #2a2a2a;
            padding: 8px 4px;
            text-align: left;
            font-weight: 600;
            color: #4a9eff;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 2px solid #444;
            font-size: 10px;
        }

        .stats-table td {
            padding: 6px 4px;
            border-bottom: 1px solid #333;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-table tr:hover {
            background: #252525;
            cursor: pointer;
        }

        .stats-table tr.selected {
            background: #354555;
            box-shadow: inset 0 0 20px rgba(74, 158, 255, 0.3);
        }
        
        /* Removed arrow - highlighting is enough */

        .owl-id, .mouse-id {
            font-weight: bold;
            color: #ffa500;
            width: 35px;
        }

        .timezone {
            font-size: 10px;
            color: #4a9eff;
            width: 50px;
            cursor: ns-resize;
            transition: all 0.2s;
            background: #1a2a3a;
            border-radius: 4px;
            padding: 4px 2px;
            text-align: center;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .timezone:hover {
            background: #2a4a6a;
            color: #6ab8ff;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        .timezone.dragging {
            background: #4a6a8a;
            color: #fff;
            box-shadow: 0 0 15px rgba(74, 158, 255, 0.8);
        }
        
        .owl-status {
            cursor: pointer;
            transition: all 0.2s;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .owl-status:hover {
            background: #354555;
            transform: scale(1.05);
        }
        
        .owl-energy {
            cursor: pointer;
        }
        
        .owl-energy:hover .activity-bar {
            border-color: #4a9eff;
            box-shadow: 0 0 5px rgba(74, 158, 255, 0.5);
        }
        
        .owl-altitude {
            cursor: ns-resize;
            transition: all 0.2s;
        }
        
        .owl-altitude:hover {
            background: #252535;
            color: #6ab8ff;
        }

        .local-time {
            font-family: monospace;
            color: #66ff66;
            font-size: 10px;
            width: 70px;
        }

        .hunting {
            color: #ff6666;
            font-weight: bold;
        }

        .resting {
            color: #6666ff;
        }

        .flying {
            color: #ffff66;
        }

        /* Activity indicators */
        .activity-bar {
            width: 60px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            display: inline-block;
            margin: 2px 0;
        }

        .activity-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd93d);
            transition: width 0.3s ease;
        }

        /* Summary stats */
        #summary-stats {
            background: #0f1419;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            font-weight: bold;
            color: #4a9eff;
            font-family: monospace;
        }

        /* Legend */
        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
        }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            min-width: 450px;
        }
        
        /* Save indicator */
        #save-indicator {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(0, 200, 0, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            font-size: 14px;
            z-index: 1000;
        }
        
        #save-indicator.show {
            opacity: 1;
        }

        .control-row {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-label {
            min-width: 45px;
            font-size: 12px;
            color: #aaa;
            margin-right: 0;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0;
            font-size: 12px;
            transition: background 0.2s;
            min-width: 100px;
        }

        button:hover {
            background: #357abd;
        }

        button.active {
            background: #ff6b6b;
        }

        input[type="range"] {
            flex: 1;
            margin: 0 5px;
            cursor: pointer;
            min-width: 200px;
        }
        
        .value-display {
            min-width: 45px;
            text-align: right;
            font-family: monospace;
            color: #4a9eff;
            font-size: 12px;
        }

        /* Mouse magnet indicator */
        .magnet-circle {
            position: absolute;
            border: 4px dashed #66ff66;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, border-color 0.3s;
        }

        .magnet-circle.active {
            opacity: 0.6;
            animation: pulse 1s ease-in-out infinite, rotateDashes 10s linear infinite;
        }
        
        /* Inner circle rotates opposite direction */
        #magnetCircleInner.active {
            animation: pulse 1s ease-in-out infinite, rotateDashesReverse 8s linear infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.05); opacity: 0.3; }
            100% { transform: scale(1); opacity: 0.6; }
        }
        
        @keyframes rotateDashes {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes rotateDashesReverse {
            from { transform: rotate(0deg); }
            to { transform: rotate(-360deg); }
        }

        /* Tooltips and info panels */
        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border: 1px solid #444;
            min-width: 220px;
            max-width: 280px;
            display: none;
        }

        .info-panel.active {
            display: block;
        }

        .info-title {
            font-weight: bold;
            color: #4a9eff;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
        }

        .info-label {
            color: #888;
        }

        .info-value {
            color: #fff;
            font-family: monospace;
        }
        
        .info-section {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .info-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .info-section-title {
            color: #4a9eff;
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        /* Column widths */
        .col-id { width: 25px; }
        .col-wizzy { width: 52px; font-size: 10px; }
        
        /* Make WIZZY clickable and SUPER OBVIOUS */
        td.col-wizzy.wizzy-button {
            cursor: pointer !important;
            padding: 6px 10px !important;
            border-radius: 8px;
            transition: all 0.2s ease;
            position: relative;
            color: #ffd700;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid transparent;
            pointer-events: auto !important;  /* FORCE clicks to work */
            z-index: 100 !important;  /* Above other elements */
        }
        
        td.col-wizzy.wizzy-button:hover {
            background: rgba(255, 215, 0, 0.4) !important;
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            border: 1px solid #ffd700;
            z-index: 10;
        }
        
        tr.selected td.col-wizzy.wizzy-button {
            background: rgba(74, 158, 255, 0.5) !important;
            box-shadow: 0 0 20px rgba(74, 158, 255, 1);
            animation: wizzyGlow 1.5s ease-in-out infinite;
            border: 1px solid #4a9eff;
            transform: scale(1) !important; /* Prevent size change */
        }
        
        @keyframes wizzyGlow {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(74, 158, 255, 1);
            }
            50% { 
                box-shadow: 0 0 30px rgba(74, 158, 255, 1), 0 0 40px rgba(255, 215, 0, 0.5);
            }
        }
        .col-tz { width: 50px; }
        .col-time { width: 70px; }
        .col-status { width: 50px; }
        .col-alt { width: 40px; }
        .col-catch { width: 25px; }
        .col-try { width: 25px; }
        .col-energy { width: 60px; }
        .col-active { width: 25px; }

        /* Mouse columns */
        .col-pos { width: 80px; }
        .col-speed { width: 50px; }
        .col-predator { width: 60px; }

        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: #252525;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .stat-card h3 {
            color: #4a9eff;
            font-size: 14px;
            margin: 0 0 10px 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 12px;
        }

        /* Creature controls */
        .creature-controls {
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .creature-controls .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .creature-controls .control-label {
            min-width: 100px;
            font-size: 13px;
            color: #aaa;
        }
        
        .creature-controls input[type="range"] {
            flex: 1;
            max-width: 300px;
        }
        
        .creature-controls .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            color: #4a9eff;
            font-size: 13px;
        }
        
        .generate-btn {
            background: #2a7a2a;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
            min-width: auto;
        }
        
        .generate-btn:hover {
            background: #3a8a3a;
        }

        /* Logging controls */
        .logging-controls {
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .logging-controls h3 {
            color: #4a9eff;
            font-size: 14px;
            margin: 0 0 15px 0;
        }

        .log-control {
            margin: 10px 0;
        }

        .log-control label {
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #aaa;
        }
        
        .log-control label span:first-child {
            width: 160px !important;
            flex-shrink: 0;
            display: inline-block;
        }

        .log-control input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }

        .log-control .value {
            width: 50px !important;
            min-width: 50px !important;
            text-align: right;
            color: #4a9eff;
            font-family: monospace;
            flex-shrink: 0;
            white-space: nowrap;
        }

        /* Console styling */
        #console-log {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 35px 10px 40px 10px;
            width: 500px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            display: none;
            min-width: 300px;
            min-height: 150px;
            max-width: 80vw;
            max-height: 80vh;
            resize: none; /* We'll handle resize manually */
        }

        #console-log.active {
            display: block;
        }
        
        #console-log::before {
            content: "üìä Simulation Console";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid #333;
            color: #4a9eff;
            font-weight: bold;
            font-size: 12px;
        }
        
        /* Console toggle button (upper right, SQUARE and SNUG) */
        #console-toggle-btn {
            position: fixed;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #4a9eff;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 20px;
            padding: 0;
            transition: all 0.2s ease;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        #console-toggle-btn:hover {
            background: rgba(74, 158, 255, 0.3);
            transform: scale(1.05);
            box-shadow: 0 3px 12px rgba(74, 158, 255, 0.5);
        }
        
        #console-toggle-btn.active {
            background: rgba(74, 158, 255, 0.4);
        }
        
        /* Console resize handle (lower left) */
        #console-resize {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: transparent;
        }
        
        #console-resize::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 2px;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 8px 8px;
            border-color: transparent transparent #666 transparent;
        }

        .log-entry {
            margin: 2px 0;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Lower left console button (HIDE IT) */
        #console-btn-small {
            display: none !important;
        }

        /* Sound controls */
        .sound-controls {
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .sound-controls h3 {
            color: #4a9eff;
            font-size: 14px;
            margin: 0 0 15px 0;
        }
        
        /* Zoom controls */
        .zoom-controls {
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .zoom-controls h3 {
            color: #4a9eff;
            font-size: 14px;
            margin: 0 0 15px 0;
        }
        
        /* Minimap controls in stats tab */
        .minimap-controls {
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .minimap-controls h3 {
            color: #4a9eff;
            font-size: 14px;
            margin: 0 0 15px 0;
        }

        .sound-toggle {
            margin-bottom: 15px;
        }

        .sound-toggle label {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #aaa;
            cursor: pointer;
        }

        .sound-toggle input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
        }
        /* Minimap styling */
        #minimap {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4a9eff;
            border-radius: 0px;
            overflow: hidden;
            z-index: 200;
            cursor: grab;
        }
        
        #minimap.dragging {
            cursor: grabbing;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        .minimap-viewport {
            position: absolute;
            border: 2px solid #80ccff;
            background: rgba(128, 204, 255, 0.3);
            pointer-events: none;
        }
        
        /* Move legend below minimap */
        #legend {
            position: fixed;
            top: 220px; /* Below minimap (20 + 180 + 20) */
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            color: #ccc;
            z-index: 150;
            pointer-events: none; /* Pass through ALL events */
        }
        
        /* Autoscroll edge indicators */
        .scroll-edge {
            position: fixed;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        
        .scroll-edge.active {
            display: block;
        }
        
        #scroll-edge-top {
            top: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.1));
        }
        
        #scroll-edge-bottom {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.1));
        }
        
        #scroll-edge-left {
            top: 0;
            left: 0;
            width: 80px;
            height: 100%;
            background: linear-gradient(to right, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.1));
        }
        
        #scroll-edge-right {
            top: 0;
            right: 0;
            width: 80px;
            height: 100%;
            background: linear-gradient(to left, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.1));
        }
    </style>
</head>
<body>
    <div id="visualization">
                        <canvas id="canvas" tabindex="0"></canvas>
        <div class="magnet-circle" id="magnetCircle"></div>
        
        <!-- Autoscroll edge indicators -->
        <div id="scroll-edge-top" class="scroll-edge"></div>
        <div id="scroll-edge-bottom" class="scroll-edge"></div>
        <div id="scroll-edge-left" class="scroll-edge"></div>
        <div id="scroll-edge-right" class="scroll-edge"></div>
        
        <!-- Inner neutral zone circle -->
        <div class="magnet-circle" id="magnetCircleInner" style="display: none;"></div>
        
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
            <div class="minimap-viewport"></div>
        </div>
        
        <div id="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ffa500;"></div>
                <span>Owls (3D flight)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #808080;"></div>
                <span>Mice (2D ground)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff0000;"></div>
                <span>Active Hunt</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #0080ff;"></div>
                <span>Resting Owl</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #66ff66; opacity: 0.3;"></div>
                <span>Mouse Magnet</span>
            </div>
        </div>
        
        <!-- Minimap controls - REMOVED FROM HERE -->
        <!--
        <div class="minimap-controls">
            ... removed ...
        </div>
        -->
        
        <div id="controls">
            <div class="control-row">
                <button onclick="resetSimulation()">üîÑ Reset</button>
                <button onclick="saveState()">üíæ Save</button>
                <button onclick="loadState()">üìÇ Load</button>
                <button id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
                <span class="control-label">Speed:</span>
                <input type="range" id="speed" min="0" max="100" step="1" value="41" oninput="updateSpeedDisplay()">
                <span class="value-display" id="speed-display">0.8x</span>
            </div>
        </div>

        <div id="info-panel" class="info-panel"></div>
    </div>

    <div id="stats-panel">
        <button id="panel-toggle" onclick="togglePanel()" title="Hide/show stats panel">
            <span id="toggle-arrow">‚óÄ</span>
        </button>
        <div id="sidebar-tab" onclick="toggleSidebar()">InfoVis</div>
        <h1>Shneiderman's Owls: Global Forest Observatory ü¶â</h1>
        <div class="subtitle" id="main-subtitle">1 Owl √ó 24 Time Zones √ó 1 Mouse</div>
        
        <div id="time-display">
            <div id="global-time">Day 1, 00:00:00 UTC</div>
            <div class="time-rate">1 day = 1 hour real time</div>
            <div class="help-label">Type ? for help. Mouse wheel zooms. Right button pans. Left button drags or energizes mouse magnet.</div>
        </div>

        <div id="summary-stats">
            <div class="stat-row">
                <span class="stat-label">Total Mice Remaining:</span>
                <span class="stat-value" id="mice-count">200</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Active Hunters:</span>
                <span class="stat-value" id="active-hunters">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Average Hunt Success:</span>
                <span class="stat-value" id="avg-success">0%</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Most Successful Owl:</span>
                <span class="stat-value" id="top-hunter">-</span>
            </div>
        </div>

        <div class="tabs">
                                        <button class="tab active" onclick="switchTab('owls')">ü¶â Owls</button>
            <button class="tab" onclick="switchTab('mice')">üê≠ Mice</button>
            <button class="tab" onclick="switchTab('stats')">üìä Stats</button>
            <button class="tab" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
            <button class="tab" onclick="switchTab('inspector')">üí© Inspector</button>
        </div>

        <div class="tab-content">
            <div id="owls-tab" class="tab-pane active">
                <div class="creature-controls">
                    <div class="control-row">
                        <span class="control-label">Active Owls:</span>
                        <input type="range" id="active-owls-slider" min="1" max="24" step="1" value="1" oninput="updateActiveOwls()">
                        <span class="value-display" id="active-owls-display">1 / 24</span>
                        <button class="generate-btn" onclick="generateNewOwl()">üé≤ Generate New</button>
                    </div>
                </div>
                <table class="stats-table" id="owl-table">
                    <thead>
                        <tr>
                            <th class="col-id" title="Owl number">#</th>
                            <th class="col-wizzy" title="Unique wizard ID with personality">WIZZY</th>
                            <th class="col-tz" title="Time zone - drag up/down to change">Zone</th>
                            <th class="col-time" title="Local time for this owl">Time</th>
                            <th class="col-status" title="Current activity - click to toggle hunting/resting">Status</th>
                            <th class="col-alt" title="Altitude in meters - drag up/down to change">Alt</th>
                            <th class="col-catch" title="Successful catches">C</th>
                            <th class="col-try" title="Total hunting attempts">T</th>
                            <th class="col-energy" title="Energy level - drag left/right to change">Energy</th>
                            <th class="col-active" title="Active period indicator (üåô night/üåû day)">A</th>
                        </tr>
                    </thead>
                    <tbody id="owl-stats">
                    </tbody>
                </table>
            </div>

            <div id="mice-tab" class="tab-pane">
                <div class="creature-controls">
                    <div class="control-row">
                        <span class="control-label">Active Mice:</span>
                        <input type="range" id="active-mice-slider" min="1" max="200" step="1" value="1" oninput="updateActiveMice()">
                        <span class="value-display" id="active-mice-display">1 / 200</span>
                        <button class="generate-btn" onclick="generateNewMouse()">üé≤ Generate New</button>
                    </div>
                </div>
                <table class="stats-table" id="mouse-table">
                    <thead>
                        <tr>
                            <th class="col-id">#</th>
                            <th class="col-wizzy">WIZZY</th>
                            <th class="col-pos">Position</th>
                            <th class="col-speed">Speed</th>
                            <th class="col-status">Status</th>
                            <th class="col-predator">Predator</th>
                            <th class="col-poop">Poops</th>
                        </tr>
                    </thead>
                    <tbody id="mouse-stats">
                    </tbody>
                </table>
            </div>

            <div id="stats-tab" class="tab-pane">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>üåç Global Stats</h3>
                        <div class="stat-item">
                            <span>Simulation Time:</span>
                            <span id="stat-sim-time">00:00:00</span>
                        </div>
                        <div class="stat-item">
                            <span>Total Hunts:</span>
                            <span id="stat-total-hunts">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Success Rate:</span>
                            <span id="stat-success-rate">0%</span>
                        </div>
                        <div class="stat-item">
                            <span>Mice Caught:</span>
                            <span id="stat-mice-caught">0</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h3>ü¶â Owl Performance</h3>
                        <div class="stat-item">
                            <span>Best Hunter:</span>
                            <span id="stat-best-hunter">-</span>
                        </div>
                        <div class="stat-item">
                            <span>Most Active:</span>
                            <span id="stat-most-active">-</span>
                        </div>
                        <div class="stat-item">
                            <span>Avg Energy:</span>
                            <span id="stat-avg-energy">100%</span>
                        </div>
                        <div class="stat-item">
                            <span>Night Owls:</span>
                            <span id="stat-night-owls">0</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h3>üê≠ Mouse Survival</h3>
                        <div class="stat-item">
                            <span>Survival Rate:</span>
                            <span id="stat-survival-rate">100%</span>
                        </div>
                        <div class="stat-item">
                            <span>Avg Speed:</span>
                            <span id="stat-avg-mouse-speed">0.0</span>
                        </div>
                        <div class="stat-item">
                            <span>Close Calls:</span>
                            <span id="stat-close-calls">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Safe Zones:</span>
                            <span id="stat-safe-zones">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Total Poops:</span>
                            <span id="stat-total-poops">0</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h3>‚è∞ Time Zone Analysis</h3>
                        <div class="stat-item">
                            <span>Most Active TZ:</span>
                            <span id="stat-active-tz">-</span>
                        </div>
                        <div class="stat-item">
                            <span>Peak Hunt Hour:</span>
                            <span id="stat-peak-hour">-</span>
                        </div>
                        <div class="stat-item">
                            <span>Dawn Hunters:</span>
                            <span id="stat-dawn-hunters">0</span>
                        </div>
                        <div class="stat-item">
                            <span>Dusk Hunters:</span>
                            <span id="stat-dusk-hunters">0</span>
                        </div>
                    </div>
                </div>

                <div class="stat-card">
                    <h3>üí© Poop Analytics</h3>
                    <div class="stat-item">
                        <span>Total Poops:</span>
                        <span id="stat-total-poops-global">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Owl Poops:</span>
                        <span id="stat-owl-poops">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Mouse Poops:</span>
                        <span id="stat-mouse-poops">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Fear Poops:</span>
                        <span id="stat-fear-poops">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Voluntary Poops:</span>
                        <span id="stat-voluntary-poops">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Auto Poops:</span>
                        <span id="stat-auto-poops">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Total Weight:</span>
                        <span id="stat-total-poop-weight">0.0 kg</span>
                    </div>
                    <div class="stat-item">
                        <span>Avg Per Creature:</span>
                        <span id="stat-avg-poop-per-creature">0.0</span>
                    </div>
                </div>

                <div class="stat-card">
                    <h3>üèÜ Poop Champions</h3>
                    <div class="stat-item">
                        <span>Most Prolific Owl:</span>
                        <span id="stat-top-pooping-owl">-</span>
                    </div>
                    <div class="stat-item">
                        <span>Most Scared Mouse:</span>
                        <span id="stat-most-scared-mouse">-</span>
                    </div>
                    <div class="stat-item">
                        <span>Highest Owl Drop:</span>
                        <span id="stat-highest-drop">0m</span>
                    </div>
                    <div class="stat-item">
                        <span>Longest Streak:</span>
                        <span id="stat-longest-poop-trail">0</span>
                    </div>
                </div>
            </div>
            
            <div id="settings-tab" class="tab-pane">
                <div class="logging-controls">
                    <h3>üéõÔ∏è Heisenbergian Logging Controls</h3>
                    <div class="log-control">
                        <label>
                            <input type="checkbox" id="heisenberg-logging-enabled" onchange="toggleHeisenbergLogging()">
                            Enable Heisenberg Logging
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>ü¶â Owl Events:</span>
                            <input type="range" id="log-owl-2" min="0" max="100" value="50" oninput="updateLogDisplay(this)">
                            <span class="value">50%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üê≠ Mouse Events:</span>
                            <input type="range" id="log-mouse-2" min="0" max="100" value="30" oninput="updateLogDisplay(this)">
                            <span class="value">30%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üí® Escape Events:</span>
                            <input type="range" id="log-escape-2" min="0" max="100" value="5" oninput="updateLogDisplay(this)">
                            <span class="value">5%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üéØ Hunt Events:</span>
                            <input type="range" id="log-hunt-2" min="0" max="100" value="80" oninput="updateLogDisplay(this)">
                            <span class="value">80%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>‚è±Ô∏è Time Events:</span>
                            <input type="range" id="log-time-2" min="0" max="100" value="20" oninput="updateLogDisplay(this)">
                            <span class="value">20%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üé≤ Random Events:</span>
                            <input type="range" id="log-random-2" min="0" max="100" value="10" oninput="updateLogDisplay(this)">
                            <span class="value">10%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üöÄ Max Log Speed:</span>
                            <input type="range" id="max-log-speed-2" min="0" max="100" value="50" oninput="updateLogDisplay(this)">
                            <span class="value">2.0x</span>
                        </label>
                    </div>
                </div>

                <div class="zoom-controls">
                    <h3>üîç Zoom Controls</h3>
                    <div class="log-control">
                        <label>
                            <span>üîç Zoom Sensitivity:</span>
                            <input type="range" id="zoomSensitivity" min="0.1" max="2.0" step="0.1" value="0.5" oninput="updateZoomDisplay()">
                            <span class="value">0.5x</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>‚å®Ô∏è Key Scroll Speed:</span>
                            <input type="range" id="keyScrollSpeed" min="50" max="500" step="10" value="300" oninput="updateKeyScrollDisplay()">
                            <span class="value">300</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>‚å®Ô∏è Key Zoom Speed:</span>
                            <input type="range" id="keyZoomSpeed" min="0.1" max="2.0" step="0.1" value="0.5" oninput="updateKeyZoomDisplay()">
                            <span class="value">0.5</span>
                        </label>
                    </div>
                </div>

                <div class="sound-controls">
                    <h3>üîä Sound Controls</h3>
                    <div class="sound-toggle">
                        <label>
                            <input type="checkbox" id="sound-enabled" onchange="toggleSound()">
                            Enable Sound Effects
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üéØ Hunt Sounds:</span>
                            <input type="range" id="sound-hunt" min="0" max="100" value="70" oninput="updateSoundDisplay(this)">
                            <span class="value">70%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üíÄ Catch Sounds:</span>
                            <input type="range" id="sound-catch" min="0" max="100" value="80" oninput="updateSoundDisplay(this)">
                            <span class="value">80%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üèÉ Escape Sounds:</span>
                            <input type="range" id="sound-escape" min="0" max="100" value="60" oninput="updateSoundDisplay(this)">
                            <span class="value">60%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üò¥ Rest Sounds:</span>
                            <input type="range" id="sound-rest" min="0" max="100" value="30" oninput="updateSoundDisplay(this)">
                            <span class="value">30%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>‚è±Ô∏è Time Ticks:</span>
                            <input type="range" id="sound-time" min="0" max="100" value="20" oninput="updateSoundDisplay(this)">
                            <span class="value">20%</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>üé≤ Ambient:</span>
                            <input type="range" id="sound-ambient" min="0" max="100" value="10" oninput="updateSoundDisplay(this)">
                            <span class="value">10%</span>
                        </label>
                    </div>
                </div>
                
                <div class="minimap-controls">
                    <h3>üó∫Ô∏è Minimap Settings</h3>
                    <div class="log-control">
                        <label>
                            <span>Mini Map Owl Size:</span>
                            <input type="range" id="minimap-owl-size" min="1" max="20" value="12" oninput="updateMinimapSizes()">
                            <span class="value">12px</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Mini Map Mouse Size:</span>
                            <input type="range" id="minimap-mouse-size" min="1" max="20" value="8" oninput="updateMinimapSizes()">
                            <span class="value">8px</span>
                        </label>
                    </div>
                </div>
                
                <div class="minimap-controls">
                    <h3>üß≤ Mouse Magnet Settings</h3>
                    <div class="log-control">
                        <label>
                            <span>Magnet Radius:</span>
                            <input type="range" id="magnetRadius" min="0" max="300" step="10" value="200" oninput="updateMagnetDisplay()">
                            <span class="value">200px</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Magnet Force:</span>
                            <input type="range" id="magnet-strength" min="-5.0" max="5.0" step="0.1" value="0.6" oninput="updateMagnetStrength()">
                            <span class="value">+3.0x</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Neutral Zone:</span>
                            <input type="range" id="magnet-neutral-zone" min="0" max="100" step="5" value="25" oninput="updateMagnetNeutralZone()">
                            <span class="value">25%</span>
                        </label>
                    </div>
                </div>
                
                <div class="minimap-controls">
                    <h3>üåü Visual Effects</h3>
                    <div class="log-control">
                        <label>
                            <span>Trail Effect:</span>
                            <input type="range" id="trails-fade" min="0" max="1.0" step="0.001" value="0.5" oninput="updateTrailsDisplay()">
                            <span class="value">50.0%</span>
                        </label>
                    </div>
                </div>
                
                <div class="minimap-controls">
                    <h3>üí© Poop System Settings</h3>
                    <div class="log-control">
                        <label>
                            <span>Auto-Poop Interval:</span>
                            <input type="range" id="poop-interval" min="1000" max="10000" step="500" value="3000" oninput="updatePoopInterval()">
                            <span class="value">3.0s</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Poop Lifetime:</span>
                            <input type="range" id="poop-fade-age" min="1000" max="30000" step="1000" value="10000" oninput="updatePoopFadeAge()">
                            <span class="value">10s</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Owl Poop Size:</span>
                            <input type="range" id="owl-poop-size" min="10" max="50" step="2" value="20" oninput="updateOwlPoopSize()">
                            <span class="value">20px</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Mouse Poop Size:</span>
                            <input type="range" id="mouse-poop-size" min="5" max="30" step="1" value="12" oninput="updateMousePoopSize()">
                            <span class="value">12px</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Owl Poop Gravity:</span>
                            <input type="range" id="poop-gravity" min="0.5" max="5.0" step="0.5" value="2.0" oninput="updatePoopGravity()">
                            <span class="value">2.0x</span>
                        </label>
                    </div>
                    <div class="log-control">
                        <label>
                            <span>Max Poops:</span>
                            <input type="range" id="max-poops" min="100" max="2000" step="100" value="500" oninput="updateMaxPoops()">
                            <span class="value">500</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div id="inspector-tab" class="tab-pane">
                <div class="minimap-controls">
                    <h3>üí© Nutrient Bag Inspector</h3>
                    <p style="font-size: 12px; color: #888; margin: 5px 0;">
                        Inspect nutrient contents of all objects. Click to update.
                    </p>
                    <button onclick="updateInspector()" style="margin: 10px 0;">üîÑ Refresh Inspector</button>
                    <div id="inspector-content" style="max-height: 600px; overflow-y: auto;">
                        <!-- Inspector content will be dynamically generated -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="console-log">
        <div id="console-resize"></div>
    </div>
    
    <!-- Floating console toggle button -->
    <button id="console-toggle-btn" onclick="toggleConsole()" title="Toggle console">
        <span id="console-icon">üìã</span>
    </button>
    
    <!-- Save indicator -->
    <div id="save-indicator">üíæ Saved!</div>
    
    <!-- Small console button in lower left -->
    <button id="console-btn-small" onclick="toggleConsole()" title="Toggle console">
        <span>üìã</span>
    </button>

    <script>



        //==============================================================================
        //
        //  I. INITIALIZATION & GLOBAL STATE
        //
        //  This is the single source of truth for the simulation's state.
        //  All variables are declared and organized here to prevent initialization
        //  errors and improve code clarity. This structure is exemplary for teaching
        //  how to manage state in a complex application.
        //
        //==============================================================================

        //------------------------------------------------------------------------------
        //  A. DOM Element Constants
        //  References to all the necessary HTML elements, fetched once at startup.
        //------------------------------------------------------------------------------
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const viz = document.getElementById('visualization');
        const infoPanel = document.getElementById('info-panel');
        const magnetCircle = document.getElementById('magnetCircle');
        const magnetCircleInner = document.getElementById('magnetCircleInner');
        const edgeIndicators = {
            top: document.getElementById('scroll-edge-top'),
            bottom: document.getElementById('scroll-edge-bottom'),
            left: document.getElementById('scroll-edge-left'),
            right: document.getElementById('scroll-edge-right')
        };
        const minimap = document.getElementById('minimap');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapViewport = document.querySelector('.minimap-viewport');
        const legend = document.getElementById('legend');
        const consoleLog = document.getElementById('console-log');


        //------------------------------------------------------------------------------
        //  B. Configuration Constants
        //  Fixed parameters that define the simulation's behavior.
        //------------------------------------------------------------------------------
        const TIME_SCALE = 3600; // 1 hour of sim time per real-time second at 1x speed
        const EDGE_SCROLL_ZONE = 80; // pixels from edge for autoscroll
        const MAX_SCROLL_SPEED = 15; // pixels per frame for autoscroll
        let keyScrollSpeed = 300;  // pixels per second for keyboard panning
        let keyZoomSpeed = 0.5; // zoom factor per second for keyboard zooming


        //------------------------------------------------------------------------------
        //  C. Global State Variables
        //  The mutable state of the simulation. Organized by function.
        //------------------------------------------------------------------------------

        // -- View & Camera State --
        let panOffset = { x: 0, y: 0 };  // The viewport's center relative to the world's center
        let viewScale = 1.0;             // The current zoom level
        let isPanning = false;           // Is the user currently panning the view?
        let panStart = { x: 0, y: 0 };   // The screen position where panning started
        let keyboardScrollVelocity = { x: 0, y: 0 }; // Velocity for keyboard panning
        let autoScrollVelocity = { x: 0, y: 0 };     // Velocity for edge-scrolling

        // -- Simulation & Time State --
        let paused = false;              // Is the simulation paused?
        let globalTime = 0;              // The in-simulation time in seconds
        let frameCount = 0;              // The total number of frames rendered
        let lastFrameTime = Date.now();  // The timestamp of the last frame
        let lastUpdateTime = 0;          // Timestamp for throttling UI updates
        let actualSpeedMultiplier = 0.8; // The current speed multiplier from the slider
        let trailsFade = 0.5;            // The alpha value for the trail effect

        // -- Entity & Interaction State --
        let owls = [];                   // Array of all Owl objects
        let mice = [];                   // Array of all Mouse objects
        let poops = [];                  // Array of all Poop objects
        let foods = [];                  // Array of all Food objects
        let activeOwlCount = 24;         // Start with 24 active owls
        let activeMouseCount = 48;       // Start with 48 active mice
        let selectedOwl = null;          // The currently selected Owl object
        let selectedMouse = null;        // The currently selected Mouse object
        let hoveredEntity = null;        // The entity currently under the mouse cursor
        let isDragging = false;          // Is the user currently dragging an entity?
        let dragTarget = null;           // The entity being dragged
        let dragOffset = { x: 0, y: 0 }; // Offset for dragging entities
        let MAX_POOPS = 500;             // Limit to prevent memory issues (adjustable in settings)
        let MAX_FOODS = 200;             // Limit for food items

        // -- UI & Settings State --
        let currentTab = 'owls';         // The active tab in the side panel
        let keysPressed = new Set();     // A set of all currently pressed keyboard keys
        let minimapConfig = { owlSize: 12, mouseSize: 8 }; // Visual settings for the minimap

        // -- Magnet State --
        let isMagnetActive = false;
        let magnetPosition = { x: 0, y: 0 };
        let magnetNeutralZone = 25;
        let magnetStrength = 3;




        
        // Initialize edge indicators
        edgeIndicators.top = document.getElementById('scroll-edge-top');
        edgeIndicators.bottom = document.getElementById('scroll-edge-bottom');
        edgeIndicators.left = document.getElementById('scroll-edge-left');
        edgeIndicators.right = document.getElementById('scroll-edge-right');
        
        let isMinimapDragging = false;
        let minimapDragStart = { x: 0, y: 0, viewX: 0, viewY: 0 };

        // Interaction state
        let isDraggingTimezone = false;
        let timezoneDragTarget = null;
        let timezoneDragStart = 0;
        let isDraggingEnergy = false;
        let energyDragTarget = null;
        let energyDragStart = 0;
        let isDraggingAltitude = false;
        let altitudeDragTarget = null;
        let altitudeDragStart = 0;
        
        // Zoom and pan state
        let viewOffset = { x: 0, y: 0 };

        let heisenbergLoggingEnabled = false;

        // Keyboard control state
        //==============================================================================
        //
        //  VIEWPORT TRANSFORM AND INTERACTION MODEL
        //  Author: The User & Gemini
        //  Date:   2024-10-27
        //
        //  This section implements a "center-based" panning and zooming model.
        //  It's designed for clarity, simplicity, and a fluid user experience.
        //
        //  Core Principles:
        //
        //  1. World Coordinates: The simulation world has a fixed size, matching the
        //     canvas dimensions. (0,0) is the top-left corner of the world.
        //
        //  2. Pan Offset: The `panOffset` variable stores the {x, y} position of the
        //     VIEWPORT'S CENTER relative to the WORLD'S CENTER, in world coordinates.
        //     - panOffset {x: 0, y: 0} means the viewport is perfectly centered.
        //     - panOffset {x: -100, y: 0} means the viewport's center is 100 world
        //       units to the left of the world's center.
        //
        //  3. Rendering Transform: To draw, we transform the canvas context with:
        //     a. Translate to the canvas center.
        //     b. Scale by `viewScale`.
        //     c. Translate by the NEGATIVE `panOffset`.
        //
        //  4. Panning: Panning is achieved by modifying `panOffset`. A mouse
        //     movement to the right *subtracts* from `panOffset.x`, making the
        //     world appear to move left under the cursor.
        //
        //  5. Zooming: Zooming modifies `viewScale` and adjusts `panOffset` to keep
        //     the world coordinate under the cursor stationary.
        //
        //  6. Clamping: Panning is permissively clamped. The viewport's *center*
        //     is not allowed to go beyond the world's boundaries. This elegantly
        //     allows the viewport edges to extend past the world when zoomed in.
        //
        //==============================================================================


        /**
         * Calculates the new panOffset required to zoom towards a specific pivot point.
         * This is the heart of the "zoom-to-cursor" logic.
         * @param {number} pivotX - The screen X coordinate of the pivot (e.g., cursor).
         * @param {number} pivotY - The screen Y coordinate of the pivot.
         * @param {number} oldScale - The viewScale *before* the zoom.
         * @param {number} newScale - The viewScale *after* the zoom.
         */
        function zoomToPoint(pivotX, pivotY, oldScale, newScale) {
            // Find the world coordinate that was under the cursor before the zoom
            const worldX = (pivotX - canvas.width / 2) / oldScale + panOffset.x;
            const worldY = (pivotY - canvas.height / 2) / oldScale + panOffset.y;

            // The new panOffset is the one that places that same world coordinate
            // back under the cursor after the zoom.
            panOffset.x = worldX - (pivotX - canvas.width / 2) / newScale;
            panOffset.y = worldY - (pivotY - canvas.height / 2) / newScale;
        }


        /**
         * Ensures the viewScale and panOffset stay within valid, permissive limits.
         */
        function constrainView() {
            const minZoom = 1.0;
            const maxZoom = 50.0; // An arbitrary but reasonable upper limit
            viewScale = Math.max(minZoom, Math.min(maxZoom, viewScale));

            // Clamp the viewport's CENTER to the world's boundaries.
            const maxPanX = canvas.width / 2;
            const maxPanY = canvas.height / 2;
            panOffset.x = Math.max(-maxPanX, Math.min(maxPanX, panOffset.x));
            panOffset.y = Math.max(-maxPanY, Math.min(maxPanY, panOffset.y));
        }


        // --- Main Canvas Interaction Handlers ---

        /**
         * Converts a screen coordinate (like a mouse click) to a world coordinate.
         * @param {number} screenX - The event's clientX.
         * @param {number} screenY - The event's clientY.
         * @returns {{x: number, y: number}} The corresponding world coordinate.
         */
        function screenToWorld(screenX, screenY) {
            const worldX = (screenX - canvas.width / 2) / viewScale + panOffset.x;
            const worldY = (screenY - canvas.height / 2) / viewScale + panOffset.y;
            return { x: worldX, y: worldY };
        }


        /**
         * Handles mouse clicks on the main canvas.
         * Manages starting panning and selecting entities.
         */
        function handleMouseDown(e) {
            // Right-click and Middle-click start panning.
            if (e.button === 2 || e.button === 1) {
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                return;
            }

            // --- Left-click logic for entity selection/magnet would go here. ---
            // This uses the new screenToWorld function to correctly find what was clicked.
            // const worldPos = screenToWorld(e.clientX, e.clientY);
            // Find entity near worldPos...
        }

        /**
         * Handles mouse movement on the main canvas for panning.
         */
        function handleMouseMove(e) {
            if (isPanning) {
                e.preventDefault();
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;

                // Convert screen-space delta to world-space pan delta.
                // A positive dx (mouse right) should decrease panOffset.x (world left).
                panOffset.x -= dx / viewScale;
                panOffset.y -= dy / viewScale;

                // The starting point for the next delta is the current position.
                panStart = { x: e.clientX, y: e.clientY };

                constrainView();
            }
            // --- Logic for dragging entities would go here. ---
        }

        /**
         * Handles releasing the mouse button to stop panning.
         */
        function handleMouseUp(e) {
            isPanning = false;
            // --- Logic for releasing dragged entities would go here. ---
        }

        /**
         * Handles the mouse wheel for zooming on the main canvas.
         * Zooms towards the cursor's position.
         */
        function handleWheel(e) {
            e.preventDefault();
            const oldScale = viewScale;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; // Zoom in on scroll up
            
            viewScale *= zoomFactor;
            constrainView(); // Clamp scale immediately

            // Adjust pan offset to keep the point under the cursor stationary
            zoomToPoint(e.clientX, e.clientY, oldScale, viewScale);
            constrainView(); // Clamp pan after adjustment
        }


        // --- Minimap Interaction Handler ---

        /**
         * Handles clicks on the minimap. Instantly centers the view on the clicked point.
         * This single function replaces all previous minimap handlers for simplicity.
         */
        function handleMinimapClick(e) {
            e.preventDefault();
            const rect = minimap.getBoundingClientRect();

            // Calculate the click position as a ratio (0.0 to 1.0) of the minimap size
            const clickRatioX = (e.clientX - rect.left) / rect.width;
            const clickRatioY = (e.clientY - rect.top) / rect.height;

            // Convert the ratio to a world coordinate.
            // The world's center is at (canvas.width / 2, canvas.height / 2).
            const worldX = clickRatioX * canvas.width;
            const worldY = clickRatioY * canvas.height;
            
            // Set the pan offset to center the view on this new world coordinate.
            panOffset.x = worldX - canvas.width / 2;
            panOffset.y = worldY - canvas.height / 2;

            constrainView();
        }





        

        function resizeCanvas() {
            const viz = document.getElementById('visualization');
            const minimap = document.getElementById('minimap');
            const legend = document.getElementById('legend');
            const minimapCanvas = document.getElementById('minimap-canvas');

            // Set main canvas size
            canvas.width = viz.offsetWidth;
            canvas.height = viz.offsetHeight;
            
            // --- DYNAMIC MINIMAP RESIZING BASED ON IMMUTABLE TRUTHS ---
            const MAX_MINIMAP_DIMENSION = 200; // Max width or height in pixels
            const MINIMAP_MARGIN = 20; // The constant gap in the top-left corner

            const aspectRatio = canvas.width / canvas.height;

            let minimapWidth, minimapHeight;

            // Calculate minimap size to fit aspect ratio within MAX_MINIMAP_DIMENSION
            if (aspectRatio > 1) { // Landscape (wide) window
                minimapWidth = MAX_MINIMAP_DIMENSION;
                minimapHeight = minimapWidth / aspectRatio;
            } else { // Portrait (tall) or square window
                minimapHeight = MAX_MINIMAP_DIMENSION;
                minimapWidth = minimapHeight * aspectRatio;
            }

            // Apply the dynamically calculated size to the minimap element and its canvas
            minimap.style.width = minimapWidth + 'px';
            minimap.style.height = minimapHeight + 'px';
            minimapCanvas.width = minimapWidth;
            minimapCanvas.height = minimapHeight;

            // The minimap's top-left position is fixed by CSS (top: 20px, left: 20px)

            // Adjust legend position to always be below the dynamically-sized minimap
            if (legend) {
                legend.style.top = (MINIMAP_MARGIN + minimapHeight + MINIMAP_MARGIN) + 'px';
            }
            
            // Re-constrain the view after a resize to handle new boundaries
            constrainView();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Smooth rotation helper for both owls and mice
        function smoothRotateTowards(entity, targetRotation, smoothing = 0.15) {
            // Calculate shortest angular distance
            let angleDiff = targetRotation - entity.rotation;
            
            // Normalize angle difference to [-PI, PI]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            // Apply smoothing
            entity.rotation += angleDiff * smoothing;
            
            // Keep rotation in [0, 2*PI] range
            while (entity.rotation < 0) entity.rotation += 2 * Math.PI;
            while (entity.rotation >= 2 * Math.PI) entity.rotation -= 2 * Math.PI;
        }

        // Feathering constants for soft fuzzy creatures
        const owlFeather = 10; // radius where owl starts fading (smaller for better painting)
        const mouseFeather = 4; // radius where mouse starts fading (smaller for better painting)
        
        // Status indicator radius (dashed circles)
        const owlStatusRadius = 14; // radius for owl status circle
        const mouseStatusRadius = 7; // radius for mouse status circle
        
        // Expanded owlish color palette (browns, grays, tawny colors, plus outliers)
        const owlishColors = [
            // Classic browns and taupes
            '#8B6F47', '#A0522D', '#D2691E', '#CD853F', '#8B7355', 
            '#6B5D54', '#736357', '#9B8579', '#8B7D6B', '#A8968A',
            '#705D56', '#7F6E5D', '#654321', '#8B4513', '#A0826D',
            
            // Light variants
            '#DEB887', '#F5DEB3', '#FFE4B5', '#FFDEAD', '#F5E6D3',
            '#E8D5B7', '#F0E68C', '#EEE8AA', '#F4E4C1', '#FFF8DC',
            
            // Dark variants
            '#3E2723', '#4E342E', '#5D4037', '#6D4C41', '#795548',
            '#33241A', '#2F1F14', '#483C32', '#534B4F', '#5C5248',
            
            // Grays
            '#696969', '#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3',
            '#2F4F4F', '#708090', '#778899', '#B0C4DE', '#DCDCDC',
            
            // Outliers
            '#FFFFFF', // Pure white
            '#000000', // Pure black
            '#FF1493', // Hot pink
            '#FFD700', // Gold
            '#FF6347', // Tomato red
            '#00CED1', // Dark turquoise
            '#9370DB', // Medium purple
            '#32CD32', // Lime green
            '#FF4500', // Orange red
            '#1E90FF'  // Dodger blue
        ];
        
        // Expanded mousy color palette (grays, browns, plus outliers)
        const mousyColors = [
            // Classic grays
            '#808080', '#A9A9A9', '#C0C0C0', '#696969', '#778899',
            '#B8B8B8', '#8B8989', '#9C9C9C', '#7A7A7A', '#8E8279',
            '#A0948C', '#D3D3D3', '#BEBEBE', '#999999', '#666666',
            
            // Browns and tans
            '#8B7D6B', '#A0826D', '#BC9A6A', '#C8B88B', '#D4C5B9',
            '#967969', '#8B7355', '#A08879', '#BCA68D', '#CDB79E',
            
            // Light variants
            '#F5F5F5', '#E8E8E8', '#DCDCDC', '#F0F0F0', '#FAFAFA',
            '#F5F5DC', '#FAF0E6', '#FFF5EE', '#F8F8FF', '#FFFAFA',
            
            // Dark variants
            '#2F2F2F', '#1C1C1C', '#363636', '#404040', '#4B4B4B',
            '#333333', '#292929', '#424242', '#525252', '#3A3A3A',
            
            // Outliers
            '#FFFFFF', // Pure white
            '#000000', // Pure black
            '#FF69B4', // Hot pink
            '#FFB6C1', // Light pink
            '#98FB98', // Pale green
            '#87CEEB', // Sky blue
            '#DDA0DD', // Plum
            '#F0E68C', // Khaki
            '#FFA07A', // Light salmon
            '#BA55D3'  // Medium orchid
        ];

        // Logging configuration
        const logConfig = {
            owl: 50,
            mouse: 30,
            escape: 1,  // VERY LOW - narrowly escapes is SUPER SPAMMY!
            hunt: 80,
            time: 20,
            random: 10,
            wizzyClick: 100,  // ALWAYS log wizzy clicks!
            maxSpeed: 2.0
        };
        
        // Track recent escapes to group them
        const recentEscapes = new Map(); // mouseId -> { count, owls: Set, lastTime }

        // Sound configuration
        let soundEnabled = false;
        const soundConfig = {
            hunt: 70,
            catch: 80,
            escape: 60,
            rest: 30,
            time: 20,
            ambient: 10
        };

        // Web Audio API setup
        let audioContext = null;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Sound generation functions
        function playSound(type, volume = 1.0) {
            if (!soundEnabled || !audioContext || soundConfig[type] === 0) return;
            
            const volumeScale = (soundConfig[type] / 100) * volume;
            // Ensure actualSpeedMultiplier is positive and finite before using it
            const safeSpeedMultiplier = Math.max(0.01, actualSpeedMultiplier || 1);
            const pitchScale = Math.min(2, Math.max(0.5, 1 / Math.sqrt(safeSpeedMultiplier)));
            
            switch(type) {
                case 'hunt':
                    playSwoosh(volumeScale, pitchScale);
                    break;
                case 'catch':
                    playChirp(volumeScale, pitchScale);
                    break;
                case 'escape':
                    playSqueak(volumeScale, pitchScale);
                    break;
                case 'rest':
                    playSoftTone(volumeScale, pitchScale);
                    break;
                case 'time':
                    playTick(volumeScale, pitchScale);
                    break;
                case 'ambient':
                    playAmbient(volumeScale, pitchScale);
                    break;
                case 'select':
                    playSelect(volumeScale, pitchScale);
                    break;
                case 'pickup':
                    playPickup(volumeScale, pitchScale);
                    break;
                case 'drop':
                    playDrop(volumeScale, pitchScale);
                    break;
                case 'magnetOn':
                    playMagnetOn(volumeScale, pitchScale);
                    break;
                case 'magnetOff':
                    playMagnetOff(volumeScale, pitchScale);
                    break;
                case 'poop':
                    playPoop(volumeScale, pitchScale);
                    break;
                case 'bounce':
                    playBounce(volumeScale, pitchScale);
                    break;
            }
        }

        // Swoosh sound for hunt start
        function playSwoosh(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800 * pitch, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100 * pitch, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3 * volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Chirp sound for successful catch
        function playChirp(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(1000 * pitch, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(1500 * pitch, audioContext.currentTime + 0.05);
            oscillator.frequency.setValueAtTime(1200 * pitch, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.4 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // Squeak sound for mouse escape
        function playSqueak(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Lower frequency for less jarring sound
            oscillator.frequency.setValueAtTime(800 * pitch, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200 * pitch, audioContext.currentTime + 0.02);
            
            // Much lower volume
            gainNode.gain.setValueAtTime(0.05 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.02);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.02); // Shorter duration
        }

        // Soft tone for owl resting
        function playSoftTone(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(300 * pitch, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.1 * volume, audioContext.currentTime + 0.1);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // Tick sound for time events
        function playTick(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(1000 * pitch, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.02);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.02);
        }

        // Ambient sound
        function playAmbient(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(500 * pitch, audioContext.currentTime);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(50 * pitch + Math.random() * 20, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.05 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Select sound (soft click)
        function playSelect(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(600 * pitch, audioContext.currentTime);
            oscillator.frequency.setValueAtTime(400 * pitch, audioContext.currentTime + 0.01);
            
            gainNode.gain.setValueAtTime(0.08 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.02);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.02);
        }
        
        // Pickup sound (rising tone)
        function playPickup(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200 * pitch, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600 * pitch, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Drop sound (falling tone)
        function playDrop(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(600 * pitch, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200 * pitch, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.1 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Magnet on sound (magnetic hum)
        function playMagnetOn(volume, pitch) {
            // Ensure finite values
            if (!isFinite(volume) || volume <= 0) volume = 1;
            if (!isFinite(pitch) || pitch <= 0) pitch = 1;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300 * pitch, audioContext.currentTime);
            filter.Q.setValueAtTime(10, audioContext.currentTime);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(60 * pitch, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.05 * volume, audioContext.currentTime + 0.05);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        // Magnet off sound (hum fade)
        function playMagnetOff(volume, pitch) {
            // Ensure finite values
            if (!isFinite(volume) || volume <= 0) volume = 1;
            if (!isFinite(pitch) || pitch <= 0) pitch = 1;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300 * pitch, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(50 * pitch, audioContext.currentTime + 0.1);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(60 * pitch, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.05 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Poop sound (comic plop!)
        function playPoop(volume, pitch) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Low pass filter for a wet sound
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200 * pitch, audioContext.currentTime);
            filter.Q.setValueAtTime(20, audioContext.currentTime);
            
            // Start high and drop low quickly (plop!)
            oscillator.frequency.setValueAtTime(300 * pitch, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(50 * pitch, audioContext.currentTime + 0.05);
            
            // Quick attack and decay for comic effect
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3 * volume, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        // Bounce sound (elastic boing!)
        function playBounce(volume, pitch) {
            // Ensure finite values
            if (!isFinite(volume) || volume <= 0) volume = 1;
            if (!isFinite(pitch) || pitch <= 0) pitch = 1;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Quick high-to-low boing
            oscillator.frequency.setValueAtTime(800 * pitch, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200 * pitch, audioContext.currentTime + 0.05);
            oscillator.frequency.setValueAtTime(400 * pitch, audioContext.currentTime + 0.05);
            oscillator.frequency.exponentialRampToValueAtTime(300 * pitch, audioContext.currentTime + 0.1);
            
            // Quick punch
            gainNode.gain.setValueAtTime(0.2 * volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Poop configuration
        const poopConfig = {
            fadeAge: 3000, // MUCH FASTER! Poop turns to food in 3 seconds instead of 10
            owlPoopSize: 20, // Owl poops are bigger!
            mousePoopSize: 12,
            owlPoopGravity: 2, // Fall speed
            splatSize: 1.5, // How much bigger when splat
            autoPoopInterval: 3000, // Default 3 seconds
            owlPoopWeight: 50, // grams per poop
            mousePoopWeight: 5  // grams per poop
        };
        
        // Archetypal flower collection
        const allFlowerEmojis = ['üå∏', 'üå∫', 'üåª', 'üå∑', 'üåπ', 'üåº', 'üíê', 'üèµÔ∏è', 'ü•Ä'];
        
        // Throwing physics constants (FIXES JAVASCRIPT ERRORS!)
        const VELOCITY_HISTORY_SIZE = 5; // Number of recent positions to track  
        const THROW_VELOCITY_SCALE = 1.0; // Multiplier for throw velocity - DOUBLED FOR ZING!
        
        // Mouse tracking variables for throwing physics (FIXES JAVASCRIPT ERRORS!)
        let lastMousePos = { x: 0, y: 0 };
        let lastMouseTime = Date.now();
        let throwVelocityHistory = [];
        
        // Food types that can spawn from decomposed poop (using emoji nutrient keys!)
        const foodTypes = [
            // Flower seed archetype - contains array of all flower types
            { emoji: 'üå±', name: 'flower seed', nutrients: { 
                'üå∏': [...allFlowerEmojis, ...allFlowerEmojis, ...allFlowerEmojis], // Triple for population
                '‚ö°': 5, 
                'üíß': 10,
                'üå±': 15 
            }},
            // Individual flowers (can spawn from MIRV)
            { 
                emoji: 'üå∏', 
                name: 'cherry blossom', 
                nutrients: { 
                    'üå∏': 'üå∏', 
                    'üåà': 5, 
                    'üåø': 2, 
                    'üòä': 1, 
                    'üå∫': 3 
                } 
            },
            { 
                emoji: 'üåº', 
                name: 'daisy', 
                nutrients: { 
                    'üå∏': 'üåº', 
                    'üåà': 3, 
                    'üêù': 4, 
                    'üòä': 2, 
                    '‚òÄÔ∏è': 1 
                } 
            },
            { 
                emoji: 'üå∫', 
                name: 'hibiscus', 
                nutrients: { 
                    'üå∏': 'üå∫', 
                    'üåà': 8, 
                    'üçØ': 6, 
                    'üèùÔ∏è': 3, 
                    'üå¥': 2 
                } 
            },
            { 
                emoji: 'üåª', 
                name: 'sunflower', 
                nutrients: { 
                    'üå∏': 'üåª', 
                    'üå∞': 10, 
                    'üíß': 5, 
                    'üìè': 7, 
                    '‚òÄÔ∏è': 8 
                } 
            },
            { 
                emoji: 'üå∑', 
                name: 'tulip', 
                nutrients: { 
                    'üå∏': 'üå∑', 
                    'üåà': 6, 
                    'üá≥üá±': 4, 
                    'üíê': 2 
                } 
            },
            { 
                emoji: 'üåπ', 
                name: 'rose', 
                nutrients: { 
                    'üå∏': 'üåπ', 
                    '‚ù§Ô∏è': 15, 
                    'ü•Ä': 3, 
                    'üíã': 5 
                } 
            },
            { 
                emoji: 'üíê', 
                name: 'bouquet', 
                nutrients: { 
                    'üå∏': 'üíê', 
                    'üíê': 25, 
                    'üéâ': 10, 
                    'üíù': 15 
                } 
            },
            
            // Other foods
            { 
                emoji: 'üçÑ', 
                name: 'mushroom', 
                nutrients: { 
                    'üçú': 7, 
                    'ü¶†': 3, 
                    '‚ú®': 1, 
                    'üåô': 2 
                } 
            },
            { 
                emoji: 'üçÉ', 
                name: 'leaf', 
                nutrients: { 
                    'üåø': 3, 
                    'üíö': 2, 
                    'üçÇ': 1, 
                    'üå≥': 1 
                } 
            },
            { 
                emoji: 'üåø', 
                name: 'herb', 
                nutrients: { 
                    'üëÖ': 4, 
                    'üíä': 3, 
                    'üëÉ': 2, 
                    'üçµ': 2 
                } 
            },
            { 
                emoji: 'üåæ', 
                name: 'grain', 
                nutrients: { 
                    'üçû': 8, 
                    '‚ö°': 6, 
                    'üåæ': 4, 
                    'üöú': 2 
                } 
            },
            { 
                emoji: 'ü•ú', 
                name: 'nut', 
                nutrients: { 
                    'üí™': 9, 
                    'üßà': 7, 
                    'ü¶∑': 5, 
                    'üêøÔ∏è': 3 
                } 
            },
            { 
                emoji: 'üå∞', 
                name: 'chestnut', 
                nutrients: { 
                    'üî•': 5, 
                    'üçÇ': 4, 
                    '‚ô®Ô∏è': 3, 
                    'üéÉ': 2 
                } 
            },
            { 
                emoji: 'ü´ò', 
                name: 'beans', 
                nutrients: { 
                    'üí™': 8, 
                    'üåø': 6, 
                    'üí®': 'fart', 
                    'üé∫': 2 
                } 
            },
            { 
                emoji: 'ü•ï', 
                name: 'carrot', 
                nutrients: { 
                    'üëÅÔ∏è': 10, 
                    'üü†': 5, 
                    'üê∞': 'whatsupdoc', 
                    'ü•ó': 3 
                } 
            },
            { 
                emoji: 'üçÄ', 
                name: 'clover', 
                nutrients: { 
                    'üçÄ': 7, 
                    'üáÆüá™': 4, 
                    'üíö': 3, 
                    'üåà': 2 
                } 
            },
            { 
                emoji: 'ü™®', 
                name: 'rock', 
                nutrients: { 
                    '‚õèÔ∏è': 5, 
                    'üíé': 10, 
                    'üßò': 2, 
                    'üóø': 3 
                } 
            },
            { 
                emoji: 'ü™µ', 
                name: 'wood', 
                nutrients: { 
                    'üåø': 4, 
                    'üêú': 2, 
                    'üî•': 3, 
                    'üå≥': 5 
                } 
            },
            { 
                emoji: 'ü•ö', 
                name: 'egg', 
                nutrients: { 
                    'üí™': 12, 
                    'ü•ö': 3, 
                    '‚ùì': 5, 
                    'üéÅ': ['üê£', 'üê•', 'ü¶ñ'] 
                } 
            },
            { 
                emoji: 'ü™∂', 
                name: 'feather', 
                nutrients: { 
                    'üïäÔ∏è': 4, 
                    'üòÜ': 3, 
                    'üõèÔ∏è': 2, 
                    '‚úíÔ∏è': 1 
                } 
            },
            { 
                emoji: 'üíé', 
                name: 'gem', 
                nutrients: { 
                    '‚ú®': 10, 
                    'üí∞': 100, 
                    'üíé': 9, 
                    'üåü': ['‚ú®', 'üí´', '‚≠ê'] 
                } 
            }
        ];
        
        class Poop {
            constructor(x, y, creatureId, creatureType, poopType = 'fear', nutrients = {}, owlAltitude = 0, owlVelocity = null) {
                this.x = x;
                this.y = y;
                this.startY = y; // For falling calculation
                this.creatureId = creatureId;
                this.creatureType = creatureType; // 'owl' or 'mouse'
                this.poopType = poopType; // 'fear', 'voluntary', 'auto'
                this.nutrients = nutrients; // Recycled nutrients
                this.age = 0;
                this.fadeAge = poopConfig.fadeAge;
                this.falling = creatureType === 'owl';
                this.splat = false;
                this.verticalVelocity = this.falling ? 0 : 0;
                this.size = creatureType === 'owl' ? poopConfig.owlPoopSize : poopConfig.mousePoopSize;
                this.originalSize = this.size; // Remember original size for scaling
                this.weight = creatureType === 'owl' ? poopConfig.owlPoopWeight : poopConfig.mousePoopWeight;
                // Calculate ground position based on owl's altitude
                this.groundY = creatureType === 'owl' ? y + owlAltitude / 2 : y;
                
                // Initial horizontal velocity - opposite of owl's direction with some randomness
                if (creatureType === 'owl' && owlVelocity) {
                    const speed = Math.sqrt(owlVelocity.x ** 2 + owlVelocity.y ** 2);
                    const angle = Math.atan2(owlVelocity.y, owlVelocity.x);
                    // Poop flies out backwards with some spread
                    const poopAngle = angle + Math.PI + (Math.random() - 0.5) * 0.5;
                    const poopSpeed = speed * 0.5 + Math.random() * 2;
                    this.horizontalVelocity = {
                        x: Math.cos(poopAngle) * poopSpeed,
                        y: Math.sin(poopAngle) * poopSpeed
                    };
                } else {
                    this.horizontalVelocity = { x: 0, y: 0 };
                }
            }
            
            update() {
                this.age += actualSpeedMultiplier;
                
                // Owl poops fall!
                if (this.falling && !this.splat) {
                    // Update vertical velocity and position
                    this.verticalVelocity += poopConfig.owlPoopGravity * actualSpeedMultiplier;
                    this.y += this.verticalVelocity * actualSpeedMultiplier;
                    
                    // Update horizontal position with air resistance
                    this.x += this.horizontalVelocity.x * actualSpeedMultiplier;
                    this.y += this.horizontalVelocity.y * actualSpeedMultiplier;
                    
                    // Apply air resistance to horizontal movement
                    this.horizontalVelocity.x *= 0.98;
                    this.horizontalVelocity.y *= 0.98;
                    
                    // Scale size based on altitude (perspective effect)
                    const fallDistance = this.y - this.startY;
                    const totalFallDistance = this.groundY - this.startY;
                    if (totalFallDistance > 0) {
                        const fallProgress = fallDistance / totalFallDistance;
                        // Start big, get smaller as it falls (but not too small)
                        this.size = this.originalSize * (1 - fallProgress * 0.3);
                    }
                    
                    // Check for ground splat (at owl's shadow position)
                    if (this.y >= this.groundY) {
                        this.y = this.groundY;
                        this.splat = true;
                        this.falling = false;
                        this.size = this.originalSize * 0.7; // Final size when splatted
                        playSound('poop', 1.2); // Extra loud splat!
                        wizzyLog('random', `üí© SPLAT! Owl poop hits the ground! üí•`, 'üí©');
                    }
                }
                
                // Check if poop should transform into food
                if (this.age >= this.fadeAge && !this.transformed) {
                    this.transformed = true;
                    
                    // MIRV! Poop can split into multiple foods based on nutrient count
                    const nutrientCount = Object.keys(this.nutrients).length;
                    const mirvCount = Math.min(nutrientCount, Math.floor(Math.random() * 3) + 1); // 1-3 foods
                    
                    const foodsCreated = [];
                    const nutrientKeys = Object.keys(this.nutrients);
                    const nutrientsPerFood = Math.ceil(nutrientCount / mirvCount);
                    
                    for (let i = 0; i < mirvCount && nutrientKeys.length > 0; i++) {
                        // Check if we have flower nutrients to spawn specific flowers
                        let foodType;
                        if (this.nutrients['üå∏']) {
                            const flowerNutrient = this.nutrients['üå∏'];
                            if (Array.isArray(flowerNutrient) && flowerNutrient.length > 0) {
                                // Pick a specific flower from the array
                                const flowerEmoji = flowerNutrient[Math.floor(Math.random() * flowerNutrient.length)];
                                // Find matching flower food type
                                foodType = foodTypes.find(f => f.emoji === flowerEmoji) || 
                                          foodTypes[Math.floor(Math.random() * foodTypes.length)];
                            } else if (typeof flowerNutrient === 'string') {
                                // Single flower type
                                foodType = foodTypes.find(f => f.emoji === flowerNutrient) || 
                                          foodTypes[Math.floor(Math.random() * foodTypes.length)];
                            } else {
                                foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
                            }
                        } else {
                            // Random food type
                            foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
                        }
                        
                        // Distribute nutrients among foods
                        const foodNutrients = {};
                        for (let j = 0; j < nutrientsPerFood && nutrientKeys.length > 0; j++) {
                            const key = nutrientKeys.splice(Math.floor(Math.random() * nutrientKeys.length), 1)[0];
                            foodNutrients[key] = this.nutrients[key];
                        }
                        
                        // Create food with recycled nutrients
                        const combinedType = {
                            emoji: foodType.emoji,
                            name: foodType.name,
                            nutrients: { ...foodType.nutrients, ...foodNutrients }
                        };
                        
                        // Scatter foods around poop location
                        const angle = (i / mirvCount) * Math.PI * 2;
                        const distance = 10 + Math.random() * 20;
                        const foodX = this.x + Math.cos(angle) * distance;
                        const foodY = this.y + Math.sin(angle) * distance;
                        
                        const newFood = new Food(foodX, foodY, combinedType);
                        foods.push(newFood);
                        foodsCreated.push(foodType.emoji);
                    }
                    
                    // Remove old foods if too many
                    while (foods.length > MAX_FOODS) {
                        foods.shift();
                    }
                    
                    if (mirvCount > 1) {
                        wizzyLog('random', `üí© MIRV! ‚Üí ${foodsCreated.join(' ')} Poop split into ${mirvCount} foods!`, 'üí•');
                    } else {
                        wizzyLog('random', `üí© ‚Üí ${foodsCreated[0]} Poop became ${foodsCreated[0]}!`, 'üå±');
                    }
                    
                    // Play extra sound for MIRV
                    if (mirvCount > 1) {
                        playSound('ambient', 1.0);
                    }
                }
            }
            
            draw() {
                if (this.age > this.fadeAge) return;
                
                const opacity = Math.max(0, 1 - (this.age / this.fadeAge));
                ctx.save();
                
                // Size changes if splat
                const currentSize = this.splat ? this.size * poopConfig.splatSize : this.size;
                
                // GREEN GLOW EFFECT! üíö
                const glowRadius = currentSize * 1.5;
                const glowGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
                glowGradient.addColorStop(0, `rgba(0, 255, 0, ${opacity * 0.08})`); // Very subtle green center
                glowGradient.addColorStop(0.3, `rgba(0, 255, 0, ${opacity * 0.05})`); // Faint green
                glowGradient.addColorStop(0.6, `rgba(0, 255, 0, ${opacity * 0.03})`); // Barely visible green
                glowGradient.addColorStop(1, 'rgba(0, 255, 0, 0)'); // Transparent edge
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Main poop emoji
                ctx.globalAlpha = opacity * 0.8;
                ctx.font = `${currentSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Different emoji for different types with extra glow for fear poops!
                const emoji = this.poopType === 'fear' ? 'üí©' : 
                             this.poopType === 'voluntary' ? 'üí©' : 
                             'üí©';
                
                // Draw shadow if falling
                if (this.falling) {
                    const shadowOpacity = opacity * 0.3 * (1 - (this.y - this.startY) / (this.groundY - this.startY));
                    ctx.globalAlpha = shadowOpacity;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.groundY, currentSize/2, currentSize/4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = opacity * 0.8;
                }
                
                // Extra bright outline for fear poops (scared mice!)
                if (this.poopType === 'fear') {
                    ctx.strokeStyle = `rgba(0, 255, 0, ${opacity * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.strokeText(emoji, this.x, this.y);
                }
                
                ctx.fillText(emoji, this.x, this.y);
                
                // Draw splat effect with green glow too!
                if (this.splat) {
                    ctx.globalAlpha = opacity * 0.4;
                    ctx.strokeStyle = `rgba(0, 255, 0, ${opacity * 0.6})`;
                    ctx.lineWidth = 1;
                    ctx.strokeText('üí•', this.x, this.y);
                    ctx.fillText('üí•', this.x, this.y);
                }
                
                ctx.restore();
            }
        }
        
        // Food class for items that appear after poop decomposes
        class Food {
            constructor(x, y, foodType) {
                this.x = x;
                this.y = y;
                this.type = foodType;
                this.emoji = foodType.emoji;
                this.name = foodType.name;
                this.nutrients = JSON.parse(JSON.stringify(foodType.nutrients)); // Deep copy
                this.age = 0;
                this.lifespan = 30000; // Foods last 30 seconds
                this.size = 16;
                this.bobOffset = Math.random() * Math.PI * 2; // Random starting phase for bobbing
            }
            
            update() {
                this.age += actualSpeedMultiplier;
                
                // Gentle bobbing animation
                this.bobAmount = Math.sin((this.age / 100) + this.bobOffset) * 2;
            }
            
            draw() {
                if (this.age > this.lifespan) return;
                
                const opacity = Math.max(0, 1 - (this.age / this.lifespan));
                ctx.save();
                ctx.globalAlpha = opacity * 0.9;
                
                // Draw shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 4, this.size/2, this.size/4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw food with bobbing
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y + this.bobAmount);
                
                // Draw sparkle effect for fresh food
                if (this.age < 1000) {
                    ctx.globalAlpha = opacity * 0.5 * (1 - this.age / 1000);
                    ctx.fillText('‚ú®', this.x + 8, this.y - 8);
                }
                
                ctx.restore();
            }
            
            isPointInside(x, y) {
                const dist = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return dist < this.size;
            }
        }

        // Time zones
        const timeZones = [
            'UTC-12', 'UTC-11', 'UTC-10', 'UTC-9', 'UTC-8', 'UTC-7',
            'UTC-6', 'UTC-5', 'UTC-4', 'UTC-3', 'UTC-2', 'UTC-1',
            'UTC+0', 'UTC+1', 'UTC+2', 'UTC+3', 'UTC+4', 'UTC+5',
            'UTC+6', 'UTC+7', 'UTC+8', 'UTC+9', 'UTC+10', 'UTC+11'
        ];

        //==============================================================================
        //
        //  WIZZY ID GENERATION
        //
        //  This section handles the creation of the unique "wizzy" identifiers for
        //  each creature. The logic is designed to be clean, simple, and exemplary.
        //
        //==============================================================================

        // Define the character sets as simple, elegant strings.
        const owlEmojis = 'ü¶âüå≥üå≤üçÉüåô‚≠êüåüüååü¶Öü™∂üçÇüå∫üå∏ü¶úüïäÔ∏èü¶öü¶¢ü™∫üåæüåø';
        const mouseEmojis = 'üê≠üßÄüåæüåΩü•úüçûü•ñüç™ü™®üå∞üçÑü•ïü´òüåªüåºüçÄüå±ü™µüçÉü´ß';
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        /**
         * Generates a unique "wizzy" identifier for a creature.
         * A wizzy is a combination of a letter and an emoji (e.g., "Aü¶â").
         *
         * @param {boolean} isOwl - True if generating for an owl, false for a mouse.
         * @returns {string} The generated wizzy ID.
         */
        function generateWizzy(characterType) {
            const letter = letters[Math.floor(Math.random() * letters.length)];
            
            // Select the correct emoji set.
            const emojiSourceString = 
                (characterType === 'owl') ? owlEmojis : mouseEmojis;
            
            // To correctly handle multi-byte emoji characters, we first convert the
            // string into an array of its individual characters.
            const emojiArray = Array.from(emojiSourceString);
            
            const emoji = emojiArray[Math.floor(Math.random() * emojiArray.length)];
            
            return letter + emoji;
        }        

        // Time formatting function
        function formatTime(totalMinutes) {
            const days = Math.floor(totalMinutes / (24 * 60));
            const dayMinutes = totalMinutes % (24 * 60);
            const hours = Math.floor(dayMinutes / 60);
            const minutes = Math.floor(dayMinutes % 60);
            const seconds = Math.floor((dayMinutes % 1) * 60);
            
            return {
                days,
                hours,
                minutes,
                seconds,
                formatted: `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`
            };
        }

        // Speed curve function (super slow at low end, SUPER FAST at high end!)
        function getSpeedMultiplier(sliderValue) {
            const normalized = sliderValue / 100;
            if (normalized < 0.1) {
                // Super slow range: 0.01x to 0.1x
                return 0.01 + (normalized * 0.9);
            } else if (normalized < 0.5) {
                // Slow to normal: 0.1x to 1x
                return 0.1 + ((normalized - 0.1) * 2.25);
            } else {
                // Normal to INSANE: 1x to 50x WTF!!!
                return 1 + ((normalized - 0.5) * 98);
            }
        }
        
        // Update autoscroll edge indicators - RELATIVE TO CANVAS NOT PAGE!
        function updateEdgeIndicators() {
            const rect = canvas.getBoundingClientRect();
            
            // Check if we're at view limits
            const worldWidth = canvas.width * viewScale;
            const worldHeight = canvas.height * viewScale;
            const canScrollLeft = worldWidth > canvas.width && viewOffset.x < 0;
            const canScrollRight = worldWidth > canvas.width && viewOffset.x > -(worldWidth - canvas.width);
            const canScrollUp = worldHeight > canvas.height && viewOffset.y < 0;
            const canScrollDown = worldHeight > canvas.height && viewOffset.y > -(worldHeight - canvas.height);
            
            // Position indicators relative to canvas
            edgeIndicators.top.style.top = rect.top + 'px';
            edgeIndicators.top.style.left = rect.left + 'px';
            edgeIndicators.top.style.width = rect.width + 'px';
            
            edgeIndicators.bottom.style.top = (rect.bottom - 80) + 'px';
            edgeIndicators.bottom.style.left = rect.left + 'px';
            edgeIndicators.bottom.style.width = rect.width + 'px';
            
            edgeIndicators.left.style.top = rect.top + 'px';
            edgeIndicators.left.style.left = rect.left + 'px';
            edgeIndicators.left.style.height = rect.height + 'px';
            
            edgeIndicators.right.style.top = rect.top + 'px';
            edgeIndicators.right.style.left = (rect.right - 80) + 'px';
            edgeIndicators.right.style.height = rect.height + 'px';
            
            // Show/hide based on scroll state and ability
            if (autoScrollVelocity.x > 0 && canScrollLeft) {
                edgeIndicators.left.classList.add('active');
            } else {
                edgeIndicators.left.classList.remove('active');
            }
            
            if (autoScrollVelocity.x < 0 && canScrollRight) {
                edgeIndicators.right.classList.add('active');
            } else {
                edgeIndicators.right.classList.remove('active');
            }
            
            if (autoScrollVelocity.y > 0 && canScrollUp) {
                edgeIndicators.top.classList.add('active');
            } else {
                edgeIndicators.top.classList.remove('active');
            }
            
            if (autoScrollVelocity.y < 0 && canScrollDown) {
                edgeIndicators.bottom.classList.add('active');
            } else {
                edgeIndicators.bottom.classList.remove('active');
            }
        }
        




        /**
         * Draws the complete minimap, including all entities and the viewport rectangle.
         * This function is called every frame from the main animation loop.
         */
        function updateMinimap() {
            //
            //  Phase 1: Draw the world background
            //
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            //
            //  Phase 2: Calculate the scaling factor to fit the entire world
            //  into the minimap with a small margin.
            //
            const worldWidth = canvas.width;
            const worldHeight = canvas.height;
            const minimapScale = Math.min(
                minimapCanvas.width / worldWidth,
                minimapCanvas.height / worldHeight
            ) * 0.9; // Use 90% of space to leave a nice border

            // Calculate the offset needed to center the scaled world inside the minimap
            const mapOffsetX = (minimapCanvas.width - worldWidth * minimapScale) / 2;
            const mapOffsetY = (minimapCanvas.height - worldHeight * minimapScale) / 2;

            //
            //  Phase 3: Draw all the entities (owls and mice) onto the minimap.
            //
            minimapCtx.textAlign = 'center';
            minimapCtx.textBaseline = 'middle';
            
            // Draw mice
            mice.forEach(mouse => {
                if (!mouse.caught && mouse.active) {
                    const x = mapOffsetX + mouse.position.x * minimapScale;
                    const y = mapOffsetY + mouse.position.y * minimapScale;
                    const isSelected = selectedMouse === mouse;
                    
                    const fontSize = Math.max(1, minimapConfig.mouseSize * (isSelected ? 3 : 1));
                    minimapCtx.font = `${fontSize}px Arial`;
                    minimapCtx.fillStyle = isSelected ? '#ffff00' : mouse.colors.middle;
                    minimapCtx.fillText(mouse.wizzy, x, y);
                }
            });
            
            // Draw owls
            owls.forEach(owl => {
                if (owl.active) {
                    const x = mapOffsetX + owl.position.x * minimapScale;
                    const y = mapOffsetY + owl.position.y * minimapScale;
                    const isSelected = selectedOwl === owl;

                    const fontSize = Math.max(1, minimapConfig.owlSize * (isSelected ? 3 : 1));
                    minimapCtx.font = `${fontSize}px Arial`;
                    minimapCtx.fillStyle = isSelected ? '#ffff00' : owl.colors.middle;
                    minimapCtx.fillText(owl.wizzy, x, y);
                }
            });

            //
            //  Phase 4: Calculate and draw the viewport rectangle. THIS IS THE KEY.
            //
            const viewportWidth = (canvas.width / viewScale) * minimapScale;
            const viewportHeight = (canvas.height / viewScale) * minimapScale;

            // The viewport's center is the minimap's center plus the scaled panOffset.
            const viewportCenterX = minimapCanvas.width / 2 + panOffset.x * minimapScale;
            const viewportCenterY = minimapCanvas.height / 2 + panOffset.y * minimapScale;

            // The viewport's top-left corner is its center minus half its size.
            const viewportX = viewportCenterX - viewportWidth / 2;
            const viewportY = viewportCenterY - viewportHeight / 2;
            
            minimapViewport.style.width = viewportWidth + 'px';
            minimapViewport.style.height = viewportHeight + 'px';
            minimapViewport.style.left = viewportX + 'px';
            minimapViewport.style.top = viewportY + 'px';
        }





        // Update minimap sizes
        function updateMinimapSizes() {
            const owlSize = document.getElementById('minimap-owl-size').value;
            const mouseSize = document.getElementById('minimap-mouse-size').value;
            
            minimapConfig.owlSize = parseInt(owlSize);
            minimapConfig.mouseSize = parseInt(mouseSize);
            
            // Update displays
            document.querySelector('#minimap-owl-size').nextElementSibling.textContent = owlSize + 'px';
            document.querySelector('#minimap-mouse-size').nextElementSibling.textContent = mouseSize + 'px';
            
            updateMinimap();
        }
        





        // --- Event Listener Registration ---
        //
        // This is the single source of truth for all view-control-related events.
        // It connects our new, clean handler functions to the DOM.
        //

        // Main canvas listeners for panning, zooming, and selection
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); // Stop panning if mouse leaves
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        canvas.addEventListener('contextmenu', e => e.preventDefault()); // Prevent right-click menu

        // Minimap listener for quick navigation
        minimap.addEventListener('click', handleMinimapClick);
        minimap.addEventListener('mousedown', handleMinimapMouseDown);
        minimap.addEventListener('mousemove', handleMinimapMouseMove);
        minimap.addEventListener('mouseup', handleMinimapMouseUp);
        minimap.addEventListener('mouseleave', handleMinimapMouseUp);

        
        function handleMinimapMouseDown(e) {
            const rect = minimap.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            isMinimapDragging = true;
            minimap.classList.add('dragging');
            
            minimapDragStart = {
                x: x,
                y: y,
                viewX: viewOffset.x,
                viewY: viewOffset.y
            };
            
            e.preventDefault();
        }
        
        function handleMinimapMouseMove(e) {
            if (!isMinimapDragging) return;
            
            const rect = minimap.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // FIXED: Use consistent minimap scale (not dependent on viewScale)
            const worldWidth = canvas.width;
            const worldHeight = canvas.height;
            const minimapScale = Math.min(
                minimapCanvas.width / worldWidth,
                minimapCanvas.height / worldHeight
            ) * 0.9;
            
            // Calculate offset for centered minimap
            const offsetX = (minimapCanvas.width - worldWidth * minimapScale) / 2;
            const offsetY = (minimapCanvas.height - worldHeight * minimapScale) / 2;
            
            // Calculate viewport center in world coordinates
            const viewportCenterX = (x - offsetX) / minimapScale;
            const viewportCenterY = (y - offsetY) / minimapScale;
            
            // Position view so viewport center is at mouse position
            viewOffset.x = -(viewportCenterX * viewScale - canvas.width / 2);
            viewOffset.y = -(viewportCenterY * viewScale - canvas.height / 2);
            
            // Apply constraints
            constrainView();
        }
        
        function handleMinimapMouseUp(e) {
            if (!isMinimapDragging && e.type === 'mouseup') {
                // Click without drag - center on clicked position
                const rect = minimap.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Calculate world scale for minimap
                const worldWidth = canvas.width * viewScale;
                const worldHeight = canvas.height * viewScale;
                const minimapScale = Math.min(
                    minimapCanvas.width / worldWidth,
                    minimapCanvas.height / worldHeight
                ) * 0.9;
                
                const offsetX = (minimapCanvas.width - worldWidth * minimapScale) / 2;
                const offsetY = (minimapCanvas.height - worldHeight * minimapScale) / 2;
                
                // Convert minimap coordinates to world coordinates
                const worldX = (x - offsetX) / minimapScale;
                const worldY = (y - offsetY) / minimapScale;
                
                // Center view on clicked position
                viewOffset.x = -(worldX * viewScale - canvas.width / 2);
                viewOffset.y = -(worldY * viewScale - canvas.height / 2);
                
                // Apply constraints
                constrainView();
            }
            
            isMinimapDragging = false;
            minimap.classList.remove('dragging');
        }
        
        function handleMinimapWheel(e) {
            e.preventDefault();
            
            // Get zoom sensitivity from slider (default 0.5)
            const sensitivity = parseFloat(document.getElementById('zoomSensitivity')?.value || 0.5);
            
            // Zoom with same behavior as main canvas
            const zoomFactor = 1 + (e.deltaY > 0 ? -0.05 : 0.05) * sensitivity;
            const oldScale = viewScale;
            viewScale = Math.max(0.5, Math.min(20, viewScale * zoomFactor));
            
            // Apply constraints after zoom
            constrainView();
            
            wizzyLog('random', `Zoomed via minimap to ${(viewScale * 100).toFixed(0)}% üîç`, 'üó∫Ô∏è');
        }

        // Duck-typed nutrient accumulation system
        function accumulateNutrients(creature, foodNutrients) {
            for (const [key, value] of Object.entries(foodNutrients)) {
                if (!(key in creature.nutrients)) {
                    // New nutrient type - just add it
                    creature.nutrients[key] = value;
                } else {
                    const existing = creature.nutrients[key];
                    
                    // Duck typing rules:
                    if (typeof existing === 'number' && typeof value === 'number') {
                        // Number + Number = sum
                        creature.nutrients[key] = existing + value;
                    } else if (Array.isArray(existing)) {
                        // Array + anything = append
                        if (Array.isArray(value)) {
                            creature.nutrients[key] = existing.concat(value);
                        } else {
                            creature.nutrients[key].push(value);
                        }
                    } else if (typeof existing === 'string' && typeof value === 'string') {
                        // String + String = Array of both
                        creature.nutrients[key] = [existing, value];
                    } else if (typeof existing === 'string' && Array.isArray(value)) {
                        // String + Array = prepend string to array
                        creature.nutrients[key] = [existing].concat(value);
                    } else if (Array.isArray(value) && typeof existing === 'string') {
                        // Array + String = append string to array
                        creature.nutrients[key] = value.concat([existing]);
                    } else {
                        // Any other combination: make array
                        creature.nutrients[key] = [existing, value];
                    }
                }
            }
        }
        
        // Split a nutrient bag into two parts based on percentage (0-1)
        function splitNutrients(nutrients, percentage = 0.5) {
            const part1 = {};
            const part2 = {};
            
            for (const [key, value] of Object.entries(nutrients)) {
                if (typeof value === 'number') {
                    // Split numbers by percentage
                    const amount1 = value * percentage;
                    const amount2 = value * (1 - percentage);
                    if (amount1 > 0) part1[key] = amount1;
                    if (amount2 > 0) part2[key] = amount2;
                } else if (Array.isArray(value) && value.length > 0) {
                    // Split arrays - randomly distribute items
                    const shuffled = [...value].sort(() => Math.random() - 0.5);
                    const splitPoint = Math.floor(shuffled.length * percentage);
                    const items1 = shuffled.slice(0, splitPoint);
                    const items2 = shuffled.slice(splitPoint);
                    if (items1.length > 0) part1[key] = items1;
                    if (items2.length > 0) part2[key] = items2;
                } else if (typeof value === 'string') {
                    // Strings go to one part based on percentage chance
                    if (Math.random() < percentage) {
                        part1[key] = value;
                    } else {
                        part2[key] = value;
                    }
                }
            }
            
            return { part1, part2 };
        }
        
        // Digest nutrients over time
        function digestNutrients(creature) {
            for (const [key, value] of Object.entries(creature.nutrients)) {
                if (typeof value === 'number') {
                    // Numbers fade down slowly
                    creature.nutrients[key] = Math.max(0, value - 0.01 * actualSpeedMultiplier);
                } else if (Array.isArray(value) && value.length > 0) {
                    // Arrays occasionally pop items (with some randomness)
                    if (Math.random() < 0.001 * actualSpeedMultiplier) {
                        creature.nutrients[key].shift(); // Remove oldest item
                    }
                }
            }
        }

        // Heisenbergian logging
        function wizzyLog(type, message, emoji = '‚ú®') {
            if (!heisenbergLoggingEnabled) return;
            if (actualSpeedMultiplier > logConfig.maxSpeed) return;
            
            const probability = logConfig[type] / 100;
            if (Math.random() > probability) return;
            
            console.log(`${emoji} ${message}`);
            
            if (consoleLog.classList.contains('active')) {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `${emoji} ${message}`;
                consoleLog.appendChild(entry);
                
                // Keep only last 20 entries
                while (consoleLog.children.length > 20) {
                    consoleLog.removeChild(consoleLog.firstChild);
                }
                
                consoleLog.scrollTop = consoleLog.scrollHeight;
            }
        }

        // Stats tracking
        const globalStats = {
            totalHunts: 0,
            successfulHunts: 0,
            closeCalls: 0,
            peakHour: { hour: 0, count: 0 },
            hourlyHunts: new Array(24).fill(0)
        };

        // 3D Boid for Owls
        class Owl {
            constructor(id, timezone) {
                this.id = id;
                this.wizzy = generateWizzy('owl');
                this.timezone = timezone;
                this.timezoneOffset = parseInt(timezone.replace('UTC', '')) || 0;
                this.active = false; // Start inactive by default
                
                // 3D position
                this.position = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    z: 50 + Math.random() * 100 // altitude 50-150
                };
                
                // 3D velocity
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: 0
                };
                
                this.acceleration = { x: 0, y: 0, z: 0 };
                this.maxSpeed = 6;
                this.maxForce = 0.2;
                
                // Owl specific attributes
                this.energy = 100;
                this.catches = 0;
                this.attempts = 0;
                this.status = 'flying';
                this.target = null;
                this.restingTime = 0;
                this.huntCooldown = 0;
                
                // Biological stats
                this.poopCount = 0;
                this.weight = 0.8 + Math.random() * 0.4; // 0.8-1.2 kg
                this.lastPoopTime = 0;
                this.lastAutoPoopTime = globalTime;
                this.totalPoopWeight = 0; // Track total kg pooped
                
                // Duck-typed nutrient system with emoji keys!
                this.nutrients = {
                    '‚ö°': 100, // energy
                    'üß†': Math.floor(Math.random() * 10), // wisdom
                    'üéà': 50, // altitude
                    'ü™∂': 1000 + Math.floor(Math.random() * 500), // feathers
                    'ü¶â': ['whoo', 'hoot'], // hoots
                    'üí≠': [], // memories
                    'üåô': Math.random() * 5, // moonlight
                    'üëÅÔ∏è': 10 // vision
                };
                
                // Activity tracking
                this.activityHistory = [];
                this.lastHuntTime = 0;
                
                // Manual control flag
                this.manualControl = false;
                this.wasInDroneMode = false;
                
                // Visual
                this.radius = 8;
                this.rotation = Math.random() * Math.PI * 2; // Start with random rotation
                // Three-color gradient system
                this.colors = {
                    inner: owlishColors[Math.floor(Math.random() * owlishColors.length)],
                    middle: owlishColors[Math.floor(Math.random() * owlishColors.length)],
                    outer: owlishColors[Math.floor(Math.random() * owlishColors.length)]
                };
                // Middle color position varies between 20% and 60% of radius
                this.middleColorPos = 0.2 + Math.random() * 0.4;
                
                wizzyLog('owl', `Owl ${this.wizzy} spawned in ${timezone} ü¶â`, 'üåü');
            }

            getLocalTime() {
                let localMinutes = (globalTime + this.timezoneOffset * 60) % (24 * 60);
                if (localMinutes < 0) localMinutes += 24 * 60;
                const hours = Math.floor(localMinutes / 60);
                const minutes = Math.floor(localMinutes % 60);
                const seconds = Math.floor((localMinutes % 1) * 60);
                return { hours, minutes, seconds, totalMinutes: localMinutes };
            }

            getFormattedLocalTime() {
                const { hours, minutes, seconds } = this.getLocalTime();
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            isActiveTime() {
                const { hours } = this.getLocalTime();
                // Owls are most active at dusk/dawn and night
                return hours < 6 || hours >= 18 || (hours >= 5 && hours < 7) || (hours >= 17 && hours < 19);
            }

            getScreenPosition() {
                const scale = 1 + this.position.z / 200;
                return {
                    x: this.position.x,
                    y: this.position.y - this.position.z / 2,
                    scale: scale
                };
            }

            isPointInside(x, y) {
                const pos = this.getScreenPosition();
                const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                // Use owlFeather for hit detection since that's the visual size
                return dist < owlFeather * pos.scale * 0.8; // 80% of visual size for better feel
            }

            update(owls, mice) {
                if (!this.active) return; // Skip inactive owls
                
                if (isDragging && dragTarget === this) {
                    // Allow position updates but skip physics
                    return;
                }

                // Always handle physics updates first
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;
                this.velocity.z += this.acceleration.z;
                
                // Limit speed
                const currentSpeed = Math.sqrt(
                    this.velocity.x ** 2 + 
                    this.velocity.y ** 2 + 
                    this.velocity.z ** 2
                );
                const maxSpeedLimit = this.status === 'droning' ? this.maxSpeed * 2 : this.maxSpeed;
                if (currentSpeed > maxSpeedLimit) {
                    const factor = maxSpeedLimit / currentSpeed;
                    this.velocity.x *= factor;
                    this.velocity.y *= factor;
                    this.velocity.z *= factor;
                }

                // Update rotation based on velocity if moving (only in non-droning autonomous modes)
                if (!this.manualControl && this.status !== 'droning' && (this.velocity.x !== 0 || this.velocity.y !== 0)) {
                    // Smooth rotation updates to prevent jerking
                    const targetRotation = Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2;
                    const rotationDiff = targetRotation - this.rotation;
                    // Normalize the difference to [-PI, PI]
                    let normalizedDiff = rotationDiff;
                    while (normalizedDiff > Math.PI) normalizedDiff -= 2 * Math.PI;
                    while (normalizedDiff < -Math.PI) normalizedDiff += 2 * Math.PI;
                    // Apply smooth rotation (10% per frame)
                    this.rotation += normalizedDiff * 0.1;
                }

                // Update position
                this.position.x += this.velocity.x * actualSpeedMultiplier;
                this.position.y += this.velocity.y * actualSpeedMultiplier;
                this.position.z += this.velocity.z * actualSpeedMultiplier;

                // Boundaries - BOUNCE off walls for owls!
                const bounceDampening = 0.85; // Lose 15% speed on bounce
                const wallMargin = 25; // Positive margin keeps owls ON SCREEN while bouncing
                
                // X boundaries - BOUNCE!
                if (this.position.x <= wallMargin) {
                    this.position.x = wallMargin;
                    this.velocity.x = Math.abs(this.velocity.x) * bounceDampening;
                    wizzyLog('random', `${this.wizzy} bounces off left wall! üèê`, 'üí•');
                    playSound('bounce', 0.7);
                } else if (this.position.x >= canvas.width - wallMargin) {
                    this.position.x = canvas.width - wallMargin;
                    this.velocity.x = -Math.abs(this.velocity.x) * bounceDampening;
                    wizzyLog('random', `${this.wizzy} bounces off right wall! üèê`, 'üí•');
                    playSound('bounce', 0.7);
                }
                
                // Y boundaries - BOUNCE!
                if (this.position.y <= wallMargin) {
                    this.position.y = wallMargin;
                    this.velocity.y = Math.abs(this.velocity.y) * bounceDampening;
                    wizzyLog('random', `${this.wizzy} bounces off top wall! üèê`, 'üí•');
                    playSound('bounce', 0.7);
                } else if (this.position.y >= canvas.height - wallMargin) {
                    this.position.y = canvas.height - wallMargin;
                    this.velocity.y = -Math.abs(this.velocity.y) * bounceDampening;
                    wizzyLog('random', `${this.wizzy} bounces off bottom wall! üèê`, 'üí•');
                    playSound('bounce', 0.7);
                }
                
                // Z boundaries (altitude) - gentle clamp
                this.position.z = Math.max(20, Math.min(200, this.position.z));

                // Reset acceleration
                this.acceleration = { x: 0, y: 0, z: 0 };

                // Skip autonomous behavior when in droning mode
                if (this.status === 'droning') {
                    // Apply friction when no input
                    if (!this.manualControl) {
                        this.velocity.x *= 0.95;
                        this.velocity.y *= 0.95;
                        this.velocity.z *= 0.9;
                    }
                    return;
                }

                const activeTime = this.isActiveTime();
                
                // Auto-exit drone mode if not selected
                if (this.status === 'droning' && selectedOwl !== this) {
                    this.status = 'flying';
                    this.wasInDroneMode = false; // Reset flag for next selection
                    wizzyLog('owl', `${this.wizzy} exits drone mode, returns to flying ü¶Ö`, 'üîÑ');
                }
                
                // Energy management
                if (this.status === 'hunting') {
                    this.energy -= 0.5 * actualSpeedMultiplier;
                } else if (this.status === 'resting') {
                    this.energy = Math.min(100, this.energy + 0.3 * actualSpeedMultiplier);
                } else {
                    this.energy -= 0.1 * actualSpeedMultiplier;
                }

                // State transitions (skip if in droning mode)
                if (this.status !== 'droning') {
                    const oldStatus = this.status;
                    if (this.energy < 20 || !activeTime) {
                        this.status = 'resting';
                        this.target = null;
                        if (oldStatus !== 'resting') {
                            wizzyLog('owl', `${this.wizzy} is tired and resting üò¥`, 'üåô');
                            playSound('rest');
                        }
                    } else if (this.energy > 60 && activeTime && this.huntCooldown <= 0) {
                        // Look for prey
                        if (!this.target || this.target.caught) {
                            this.target = this.findNearestMouse(mice);
                            if (this.target) {
                                this.status = 'hunting';
                                this.attempts++;
                                globalStats.totalHunts++;
                                const hour = this.getLocalTime().hours;
                                globalStats.hourlyHunts[hour]++;
                                wizzyLog('hunt', `${this.wizzy} spots prey ${this.target.wizzy} and begins hunting! üéØ`, 'üî•');
                                playSound('hunt');
                            }
                        }
                    }
                }

                // Behavior based on status
                if (this.status === 'hunting' && this.target) {
                    this.hunt();
                } else if (this.status === 'resting') {
                    this.rest();
                } else if (this.status === 'flying') {
                    this.patrol(owls);
                }
                // Droning mode does nothing autonomous

                // Update cooldowns
                if (this.huntCooldown > 0) this.huntCooldown -= actualSpeedMultiplier;
                
                // Digest nutrients
                digestNutrients(this);
                
                // Auto-poop logic
                if (globalTime - this.lastAutoPoopTime > poopConfig.autoPoopInterval) {
                    this.poop(false); // Auto poop
                    this.lastAutoPoopTime = globalTime;
                }
                
                // Random wizzy events
                if (Math.random() < 0.001 * actualSpeedMultiplier) {
                    wizzyLog('random', `${this.wizzy} does a barrel roll! üåÄ`, 'üé™');
                    playSound('ambient', 0.2);
                }
            }

            setTimezone(newTimezone) {
                const oldTz = this.timezone;
                this.timezone = newTimezone;
                this.timezoneOffset = parseInt(newTimezone.replace('UTC', '')) || 0;
                wizzyLog('time', `${this.wizzy} warped from ${oldTz} to ${newTimezone}! ‚è∞`, 'üåç');
            }

            findNearestMouse(mice) {
                let nearest = null;
                let minDist = this.position.z * 3; // Vision range based on altitude

                mice.forEach(mouse => {
                    if (mouse.active && !mouse.caught) { // Only hunt active mice
                        const dist = this.distance2D(this.position, mouse.position);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = mouse;
                        }
                    }
                });

                return nearest;
            }

            hunt() {
                if (!this.target || this.target.caught) {
                    this.status = 'flying';
                    this.target = null;
                    return;
                }

                // Dive towards prey
                const dx = this.target.position.x - this.position.x;
                const dy = this.target.position.y - this.position.y;
                const dz = 0 - this.position.z; // Dive to ground
                
                const dist = Math.sqrt(dx * dx + dy * dy + this.position.z * this.position.z);
                
                if (dist < 20 && this.position.z < 30) {
                    // Scare attempt
                    const successChance = 0.7 - (this.energy < 50 ? 0.2 : 0);
                    if (Math.random() < successChance) {
                        // SCARE NUTRIENTS OUT!
                        if (globalTime - this.target.lastPoopTime > 50) { // Shorter cooldown for more fear poops!
                            // Split mouse nutrients 50/50 between owl and poop
                            const { part1: owlGains, part2: mouseKeeps } = splitNutrients(this.target.nutrients, 0.5);
                            
                            // Owl gains some nutrients from scare
                            accumulateNutrients(this, owlGains);
                            
                            // Mouse keeps half their nutrients
                            this.target.nutrients = mouseKeeps;
                            
                            // Mouse poops the nutrients the owl gained!
                            this.target.poop(false); // This will now poop from reduced nutrients
                            
                            this.scares = (this.scares || 0) + 1;
                            this.energy = Math.min(100, this.energy + 20); // Less energy than catching
                            this.lastHuntTime = globalTime;
                            globalStats.successfulHunts++;
                            
                            // Count nutrients gained
                            const gainedCount = Object.keys(owlGains).length;
                            wizzyLog('hunt', `${this.wizzy} scared ${gainedCount} nutrients out of ${this.target.wizzy}! Total scares: ${this.scares} üò±`, 'üí©');
                            playSound('poop');
                            
                            // Mouse runs away at double speed (safety check for NaN)
                            if (!isNaN(this.target.velocity.x) && !isNaN(this.target.velocity.y)) {
                                this.target.velocity.x *= 2;
                                this.target.velocity.y *= 2;
                            }
                        }
                    } else {
                        wizzyLog('hunt', `${this.wizzy} missed! ${this.target.wizzy} escapes! üèÉ`, 'üí®');
                        playSound('escape', 0.3); // Lower volume for misses too
                    }
                    this.status = 'flying';
                    this.target = null;
                    this.huntCooldown = 60; // Wait before next hunt
                    
                    // Climb back up
                    this.velocity.z = 2;
                } else {
                    // Continue diving
                    this.acceleration.x = dx * 0.02;
                    this.acceleration.y = dy * 0.02;
                    this.acceleration.z = dz * 0.03;
                }
            }

            rest() {
                // Find a high perch
                if (this.position.z < 150) {
                    this.acceleration.z = 0.5;
                }
                
                // Slow down
                this.velocity.x *= 0.95;
                this.velocity.y *= 0.95;
                this.velocity.z *= 0.95;
                
                this.restingTime += actualSpeedMultiplier;
                
                if (this.restingTime > 100 && this.energy > 80) {
                    this.status = 'flying';
                    this.restingTime = 0;
                    wizzyLog('owl', `${this.wizzy} is refreshed and ready to fly! üí™`, 'üåü');
                    playSound('ambient', 0.4);
                }
            }

            patrol(owls) {
                // 3D flocking behavior
                const perception = 100;
                let alignment = { x: 0, y: 0, z: 0 };
                let cohesion = { x: 0, y: 0, z: 0 };
                let separation = { x: 0, y: 0, z: 0 };
                let total = 0;

                owls.forEach(other => {
                    if (other !== this && other.active) { // Only flock with active owls
                        const dist = this.distance3D(this.position, other.position);
                        if (dist < perception) {
                            // Alignment
                            alignment.x += other.velocity.x;
                            alignment.y += other.velocity.y;
                            alignment.z += other.velocity.z;
                            
                            // Cohesion
                            cohesion.x += other.position.x;
                            cohesion.y += other.position.y;
                            cohesion.z += other.position.z;
                            
                            // Separation
                            if (dist < 50) {
                                const diff = {
                                    x: this.position.x - other.position.x,
                                    y: this.position.y - other.position.y,
                                    z: this.position.z - other.position.z
                                };
                                diff.x /= dist;
                                diff.y /= dist;
                                diff.z /= dist;
                                separation.x += diff.x;
                                separation.y += diff.y;
                                separation.z += diff.z;
                            }
                            
                            total++;
                        }
                    }
                });

                if (total > 0) {
                    // Apply flocking forces
                    alignment.x /= total;
                    alignment.y /= total;
                    alignment.z /= total;
                    
                    cohesion.x = cohesion.x / total - this.position.x;
                    cohesion.y = cohesion.y / total - this.position.y;
                    cohesion.z = cohesion.z / total - this.position.z;
                    
                    this.acceleration.x += alignment.x * 0.1 + cohesion.x * 0.05 + separation.x * 0.15;
                    this.acceleration.y += alignment.y * 0.1 + cohesion.y * 0.05 + separation.y * 0.15;
                    this.acceleration.z += alignment.z * 0.1 + cohesion.z * 0.05 + separation.z * 0.15;
                }

                // Random wander
                this.acceleration.x += (Math.random() - 0.5) * 0.1;
                this.acceleration.y += (Math.random() - 0.5) * 0.1;
                this.acceleration.z += (Math.random() - 0.5) * 0.05;
            }

            distance2D(a, b) {
                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
            }

            distance3D(a, b) {
                return Math.sqrt(
                    (a.x - b.x) ** 2 + 
                    (a.y - b.y) ** 2 + 
                    (a.z - b.z) ** 2
                );
            }
            
            poop(isManual = false) {
                const poopType = isManual ? 'voluntary' : 'auto';
                
                // Select nutrients to expel (recycling system)
                const nutrientKeys = Object.keys(this.nutrients).filter(k => {
                    const v = this.nutrients[k];
                    return (typeof v === 'number' && v > 0) || 
                           (Array.isArray(v) && v.length > 0) || 
                           (typeof v === 'string');
                });
                
                // Different poop types based on mood/digestion
                const poopMood = Math.random();
                let expelledNutrients = {};
                
                if (poopMood < 0.25 && nutrientKeys.length > 0) {
                    // Pure single nutrient poop (25% chance)
                    const key = nutrientKeys[Math.floor(Math.random() * nutrientKeys.length)];
                    const value = this.nutrients[key];
                    
                    if (typeof value === 'number' && value > 0) {
                        const amount = Math.min(value, Math.random() * 20 + 15);
                        expelledNutrients[key] = amount;
                        this.nutrients[key] -= amount;
                    } else if (Array.isArray(value) && value.length > 0) {
                        expelledNutrients[key] = value.splice(0, Math.min(value.length, 8));
                    } else if (typeof value === 'string') {
                        expelledNutrients[key] = value;
                        delete this.nutrients[key];
                    }
                    wizzyLog('random', `${this.wizzy} pure ${key} bomb! üí©`, 'üéØ');
                } else if (poopMood < 0.5) {
                    // Mixed balanced nutrients (25% chance)
                    const numNutrients = Math.min(nutrientKeys.length, Math.floor(Math.random() * 3) + 2); // 2-4 nutrients
                    for (let i = 0; i < numNutrients; i++) {
                        const idx = Math.floor(Math.random() * nutrientKeys.length);
                        const key = nutrientKeys.splice(idx, 1)[0];
                        const value = this.nutrients[key];
                        
                        if (typeof value === 'number' && value > 0) {
                            const amount = Math.min(value, Math.random() * 15 + 5);
                            expelledNutrients[key] = amount;
                            this.nutrients[key] -= amount;
                        } else if (Array.isArray(value) && value.length > 0) {
                            const count = Math.min(value.length, Math.floor(Math.random() * 4) + 1);
                            expelledNutrients[key] = value.splice(0, count);
                        } else if (typeof value === 'string') {
                            expelledNutrients[key] = value;
                            delete this.nutrients[key];
                        }
                    }
                } else {
                    // Random combo (50% chance)
                    const numNutrients = Math.min(nutrientKeys.length, Math.floor(Math.random() * 6) + 1); // 1-6 nutrients
                    for (let i = 0; i < numNutrients; i++) {
                        const idx = Math.floor(Math.random() * nutrientKeys.length);
                        const key = nutrientKeys.splice(idx, 1)[0];
                        const value = this.nutrients[key];
                        
                        if (typeof value === 'number' && value > 0) {
                            const amount = Math.min(value, Math.random() * 25 + 1);
                            expelledNutrients[key] = amount;
                            this.nutrients[key] -= amount;
                        } else if (Array.isArray(value) && value.length > 0) {
                            const count = Math.min(value.length, Math.floor(Math.random() * value.length) + 1);
                            expelledNutrients[key] = value.splice(0, count);
                        } else if (typeof value === 'string') {
                            expelledNutrients[key] = value;
                            delete this.nutrients[key];
                        }
                    }
                }
                
                // Owl poops fall from their altitude!
                const dropY = this.position.y - this.position.z / 2; // Adjust for screen position
                const newPoop = new Poop(
                    this.position.x,
                    dropY,
                    this.wizzy,
                    'owl',
                    poopType,
                    expelledNutrients,
                    this.position.z,  // Pass altitude for ground calculation
                    this.velocity     // Pass owl velocity for poop physics
                );
                
                poops.push(newPoop);
                this.poopCount++;
                this.totalPoopWeight += poopConfig.owlPoopWeight / 1000; // Convert to kg
                this.lastPoopTime = globalTime;
                
                // Remove old poops if too many
                if (poops.length > MAX_POOPS) {
                    poops.shift();
                }
                
                // Propulsion! Pooping makes owl go faster in forward direction
                const propulsionForce = 3; // Jet propulsion strength
                const angle = Math.atan2(this.velocity.y, this.velocity.x);
                this.velocity.x += Math.cos(angle) * propulsionForce;
                this.velocity.y += Math.sin(angle) * propulsionForce;
                
                // Also gain altitude from relief
                this.velocity.z += 2;
                
                const nutrientList = Object.entries(expelledNutrients).map(([k,v]) => 
                    `${k}:${Array.isArray(v) ? v.length : typeof v === 'number' ? v.toFixed(1) : v}`
                ).join(', ');
                wizzyLog('random', `${this.wizzy} drops nutrients from ${Math.round(this.position.z)}m! [${nutrientList}] üí©‚¨áÔ∏è`, 'ü¶â');
                playSound('poop', 0.8);
            }

            draw() {
                if (!this.active) return; // Skip inactive owls
                
                const pos = this.getScreenPosition();

                ctx.save();
                
                // Move to owl position
                ctx.translate(pos.x, pos.y);
                
                // Draw golden halo if selected (before rotation so it doesn't rotate)
                const scaleFactor = selectedOwl === this ? 1.1 : 1; // Even smaller size increase when selected
                if (selectedOwl === this) {
                    const haloRadius = owlFeather * pos.scale * 1.3; // Even smaller halo
                    const haloGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, haloRadius);
                    
                    // Much more subtle golden halo
                    haloGradient.addColorStop(0, 'rgba(255, 215, 0, 0)'); // Transparent center
                    haloGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.1)'); // Very faint gold
                    haloGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.15)'); // Slightly brighter
                    haloGradient.addColorStop(0.8, 'rgba(255, 215, 0, 0.1)'); // Fading
                    haloGradient.addColorStop(1, 'rgba(255, 215, 0, 0)'); // Fully transparent
                    
                    ctx.fillStyle = haloGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, haloRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Apply rotation (always use stored rotation)
                ctx.rotate(this.rotation);
                
                // Create feathered gradient with three colors (no status tinting)
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, owlFeather * pos.scale * scaleFactor);
                
                // Pure three-color gradient with natural feathering
                gradient.addColorStop(0, this.colors.inner + 'FF'); // Inner color, full opacity
                gradient.addColorStop(this.middleColorPos * 0.7, this.colors.inner + 'DD');
                gradient.addColorStop(this.middleColorPos, this.colors.middle + 'CC'); // Middle color
                gradient.addColorStop(this.middleColorPos * 1.3, this.colors.middle + '99');
                gradient.addColorStop(0.7, this.colors.outer + '66'); // Outer color starts fading
                gradient.addColorStop(0.85, this.colors.outer + '33');
                gradient.addColorStop(1, this.colors.outer + '00'); // Fully transparent

                // Draw fuzzy owl body
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, owlFeather * pos.scale * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw status indicator as dashed circle with 0.5 opacity
                ctx.save();
                ctx.globalAlpha = 0.5;
                
                // Status indicators - same size regardless of selection
                const statusRadius = owlStatusRadius * pos.scale;
                
                if (this.status === 'droning') {
                    // Droning mode - bright purple with tight dashes
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3 * pos.scale;
                    ctx.setLineDash([4 * pos.scale, 4 * pos.scale]);
                } else if (this.status === 'hunting') {
                    // Hunting - red with wide gaps (vents open)
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2.5 * pos.scale;
                    ctx.setLineDash([8 * pos.scale, 12 * pos.scale]);
                } else if (this.status === 'resting') {
                    // Resting - blue with tight dashes (vents closed)
                    ctx.strokeStyle = '#4444ff';
                    ctx.lineWidth = 2 * pos.scale;
                    ctx.setLineDash([3 * pos.scale, 3 * pos.scale]);
                } else {
                    // Flying - orange with medium dashes
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2 * pos.scale;
                    ctx.setLineDash([6 * pos.scale, 6 * pos.scale]);
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, statusRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Reset line dash
                ctx.setLineDash([]);
                
                // Draw temporary control indicator if applicable
                if (this.manualControl && this.status !== 'droning') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 1 * pos.scale;
                    ctx.beginPath();
                    ctx.arc(0, 0, statusRadius * 1.1, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();

                // WIZZY ID label - split into letters and emojis
                const letters = this.wizzy.match(/[A-Z]/g) || [];
                const emojis = this.wizzy.match(/[^\w\s]/g) || [];
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw WIZZY ID as single string (emojis render better this way)
                ctx.font = `bold ${8 * pos.scale}px Arial`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowBlur = 2 * pos.scale;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.fillText(this.wizzy, 0, 0);

                ctx.restore();
            }
        }

        // 2D Boid for Mice
        class Mouse {
            constructor(index) {
                this.active = false; // Start inactive by default
                this.position = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                this.acceleration = { x: 0, y: 0 };
                this.maxSpeed = 3;
                this.maxForce = 0.05;
                this.caught = false;
                this.caughtBy = null;
                this.radius = 3;
                this.id = Math.random().toString(36).substr(2, 9);
                this.wizzy = generateWizzy('mouse');
                this.closeCallCount = 0;
                this.rotation = Math.random() * Math.PI * 2; // Start with random rotation
                // Three-color gradient system
                this.colors = {
                    inner: mousyColors[Math.floor(Math.random() * mousyColors.length)],
                    middle: mousyColors[Math.floor(Math.random() * mousyColors.length)],
                    outer: mousyColors[Math.floor(Math.random() * mousyColors.length)]
                };
                // Middle color position varies between 20% and 60% of radius
                this.middleColorPos = 0.2 + Math.random() * 0.4;
                
                // Biological stats
                this.poopCount = 0;
                this.weight = 20 + Math.random() * 20; // 20-40 grams
                this.lastPoopTime = 0;
                this.lastAutoPoopTime = globalTime;
                this.totalPoopWeight = 0; // Track total kg pooped
                
                // Duck-typed nutrient system with emoji keys!
                this.nutrients = {
                    '‚ö°': 50, // energy
                    'üí®': 3, // speed
                    'üê≠': 12 + Math.floor(Math.random() * 6), // whiskers
                    'üîä': ['eek', 'squeak'], // squeaks
                    'üí≠': [], // dreams
                    'üí™': Math.random() * 5, // courage
                    'üßÄ': Math.random() * 10, // cheese desire
                    'üëÉ': 5 // smell
                };
                
                // Manual control flag
                this.manualControl = false;
                this.wasInDroneMode = false;
                this.status = 'foraging'; // Mice have status too: foraging, fleeing, droning
                
                wizzyLog('mouse', `Mouse ${this.wizzy} spawned! üê≠`, '‚ú®');
            }

            isPointInside(x, y) {
                const dist = Math.sqrt((x - this.position.x) ** 2 + (y - this.position.y) ** 2);
                // Use mouseFeather for hit detection since that's the visual size
                return dist < mouseFeather * 0.8; // 80% of visual size for better feel
            }
            
            poop(isManual = false) {
                const poopType = isManual ? 'voluntary' : 'auto';
                
                // Select nutrients to expel (recycling system)
                const nutrientKeys = Object.keys(this.nutrients).filter(k => {
                    const v = this.nutrients[k];
                    return (typeof v === 'number' && v > 0) || 
                           (Array.isArray(v) && v.length > 0) || 
                           (typeof v === 'string');
                });
                
                // Different poop types for mice (smaller, more frequent)
                const poopMood = Math.random();
                let expelledNutrients = {};
                
                if (poopMood < 0.4 && nutrientKeys.length > 0) {
                    // Pure single nutrient pellet (40% chance for mice)
                    const key = nutrientKeys[Math.floor(Math.random() * nutrientKeys.length)];
                    const value = this.nutrients[key];
                    
                    if (typeof value === 'number' && value > 0) {
                        const amount = Math.min(value, Math.random() * 8 + 2);
                        expelledNutrients[key] = amount;
                        this.nutrients[key] -= amount;
                    } else if (Array.isArray(value) && value.length > 0) {
                        expelledNutrients[key] = value.splice(0, Math.min(value.length, 3));
                    } else if (typeof value === 'string') {
                        expelledNutrients[key] = value;
                        delete this.nutrients[key];
                    }
                    wizzyLog('random', `${this.wizzy} pure ${key} pellet! üí©`, 'üéØ');
                } else {
                    // Mixed pellet (60% chance)
                    const numNutrients = Math.min(nutrientKeys.length, Math.floor(Math.random() * 3) + 1); // 1-3 nutrients
                    for (let i = 0; i < numNutrients; i++) {
                        const idx = Math.floor(Math.random() * nutrientKeys.length);
                        const key = nutrientKeys.splice(idx, 1)[0];
                        const value = this.nutrients[key];
                        
                        if (typeof value === 'number' && value > 0) {
                            const amount = Math.min(value, Math.random() * 5 + 1);
                            expelledNutrients[key] = amount;
                            this.nutrients[key] -= amount;
                        } else if (Array.isArray(value) && value.length > 0) {
                            const count = Math.min(value.length, Math.floor(Math.random() * 2) + 1);
                            expelledNutrients[key] = value.splice(0, count);
                        } else if (typeof value === 'string') {
                            expelledNutrients[key] = value;
                            delete this.nutrients[key];
                        }
                    }
                }
                
                // Mouse poops at current position
                const newPoop = new Poop(
                    this.position.x,
                    this.position.y,
                    this.wizzy,
                    'mouse',
                    poopType,
                    expelledNutrients
                );
                
                poops.push(newPoop);
                this.poopCount++;
                this.totalPoopWeight += poopConfig.mousePoopWeight / 1000; // Convert to kg
                this.lastPoopTime = globalTime;
                
                // Remove old poops if too many
                if (poops.length > MAX_POOPS) {
                    poops.shift();
                }
                
                // Move forward a bit after pooping
                const pushForce = 0.5;
                this.velocity.x += Math.sin(this.rotation) * pushForce;
                this.velocity.y += -Math.cos(this.rotation) * pushForce;
                
                const nutrientList = Object.entries(expelledNutrients).map(([k,v]) => 
                    `${k}:${Array.isArray(v) ? v.length : typeof v === 'number' ? v.toFixed(1) : v}`
                ).join(', ');
                wizzyLog('random', `${this.wizzy} drops pellet! [${nutrientList}] üí©`, 'üê≠');
                playSound('poop', 0.6);
            }

            update(mice, owls) {
                if (!this.active || this.caught) return; // Skip inactive or caught mice
                if (isDragging && dragTarget === this) {
                    // Allow drawing but skip physics
                    return;
                }

                // Always handle physics updates first
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;
                
                // Limit speed
                const currentSpeed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                const maxSpeedLimit = this.status === 'droning' ? this.maxSpeed * 2 : this.maxSpeed;
                if (currentSpeed > maxSpeedLimit) {
                    this.velocity.x = (this.velocity.x / currentSpeed) * maxSpeedLimit;
                    this.velocity.y = (this.velocity.y / currentSpeed) * maxSpeedLimit;
                }

                // Update rotation based on velocity if moving (only in non-droning autonomous modes)
                if (!this.manualControl && this.status !== 'droning' && (this.velocity.x !== 0 || this.velocity.y !== 0)) {
                    // Smooth rotation updates to prevent jerking
                    const targetRotation = Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2;
                    const rotationDiff = targetRotation - this.rotation;
                    // Normalize the difference to [-PI, PI]
                    let normalizedDiff = rotationDiff;
                    while (normalizedDiff > Math.PI) normalizedDiff -= 2 * Math.PI;
                    while (normalizedDiff < -Math.PI) normalizedDiff += 2 * Math.PI;
                    // Apply smooth rotation (10% per frame)
                    this.rotation += normalizedDiff * 0.1;
                }

                // Update position
                this.position.x += this.velocity.x * actualSpeedMultiplier;
                this.position.y += this.velocity.y * actualSpeedMultiplier;

                // World wrapping for mice only! (helps them escape)
                if (this.position.x < 0) this.position.x = canvas.width;
                if (this.position.x >= canvas.width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = canvas.height;
                if (this.position.y >= canvas.height) this.position.y = 0;
                
                // Reset acceleration
                this.acceleration = { x: 0, y: 0 };

                // Auto-exit drone mode if not selected
                if (this.status === 'droning' && selectedMouse !== this) {
                    this.status = 'foraging';
                    this.wasInDroneMode = false; // Reset flag for next selection
                    wizzyLog('mouse', `${this.wizzy} exits drone mode, returns to foraging üåæ`, 'üîÑ');
                }

                // Skip autonomous behavior when in droning mode
                if (this.status === 'droning') {
                    // Apply friction when no input
                    if (!this.manualControl) {
                        this.velocity.x *= 0.95;
                        this.velocity.y *= 0.95;
                    }
                    
                    // IMPORTANT: Boundary wrapping for droning mice too!
                    if (this.position.x < 0) this.position.x = canvas.width;
                    if (this.position.x >= canvas.width) this.position.x = 0;
                    if (this.position.y < 0) this.position.y = canvas.height;
                    if (this.position.y >= canvas.height) this.position.y = 0;
                    
                    return;
                }

                // Basic flocking
                const perception = 25;
                let alignment = { x: 0, y: 0 };
                let cohesion = { x: 0, y: 0 };
                let separation = { x: 0, y: 0 };
                let total = 0;

                // Mouse magnet attraction
                let magnetForce = { x: 0, y: 0 };
                if (isMagnetActive) {
                    const magnetRadius = parseFloat(document.getElementById('magnetRadius').value);
                    const neutralRadius = magnetRadius * (magnetNeutralZone / 100);
                    const dist = Math.sqrt(
                        (this.position.x - magnetPosition.x) ** 2 +
                        (this.position.y - magnetPosition.y) ** 2
                    );
                    
                    // Only apply force if outside neutral zone
                    if (dist < magnetRadius && dist > neutralRadius) {
                        // Use magnetStrength variable (can be negative for repulsion)
                        const effectiveDist = dist - neutralRadius;
                        const effectiveRadius = magnetRadius - neutralRadius;
                        const strength = magnetStrength * (1 - effectiveDist / effectiveRadius);
                        magnetForce.x = (magnetPosition.x - this.position.x) / dist * strength;
                        magnetForce.y = (magnetPosition.y - this.position.y) / dist * strength;
                    }
                }

                // Flee from owls
                let flee = { x: 0, y: 0 };
                owls.forEach(owl => {
                    if (owl.active && owl.status === 'hunting' && owl.position.z < 50) { // Only flee from active owls
                        const dist = Math.sqrt(
                            (this.position.x - owl.position.x) ** 2 +
                            (this.position.y - owl.position.y) ** 2
                        );
                        if (dist < 100) {
                            if (dist < 30) {
                                this.closeCallCount++;
                                globalStats.closeCalls++;
                                
                                // Track escapes for grouped logging
                                const now = Date.now();
                                if (!recentEscapes.has(this.id)) {
                                    recentEscapes.set(this.id, { count: 0, owls: new Set(), lastTime: now });
                                }
                                const escapeData = recentEscapes.get(this.id);
                                escapeData.count++;
                                escapeData.owls.add(owl.wizzy);
                                escapeData.lastTime = now;
                                
                                // Only log occasionally and with very low probability
                                if (Math.random() < logConfig.escape / 100) {
                                    if (escapeData.count > 1) {
                                        wizzyLog('escape', `${this.wizzy} has escaped ${escapeData.count} times from ${Array.from(escapeData.owls).join(', ')}! üò±`, 'üí®üí®üí®');
                                    } else {
                                        wizzyLog('escape', `${this.wizzy} narrowly escapes from ${owl.wizzy}! üò±`, 'üí®');
                                    }
                                }
                                playSound('escape', 0.2); // Even quieter for close calls
                            }
                            const diff = {
                                x: this.position.x - owl.position.x,
                                y: this.position.y - owl.position.y
                            };
                            // Fix division by zero that causes NaN!
                            if (dist > 0) {
                                diff.x /= dist;
                                diff.y /= dist;
                                flee.x += diff.x * 5;
                                flee.y += diff.y * 5;
                            }
                        }
                    }
                });

                mice.forEach(other => {
                    if (other !== this && other.active && !other.caught) { // Only flock with active mice
                        const dist = Math.sqrt(
                            (this.position.x - other.position.x) ** 2 +
                            (this.position.y - other.position.y) ** 2
                        );
                        
                        if (dist < perception) {
                            alignment.x += other.velocity.x;
                            alignment.y += other.velocity.y;
                            
                            cohesion.x += other.position.x;
                            cohesion.y += other.position.y;
                            
                            if (dist < 10) {
                                const diff = {
                                    x: this.position.x - other.position.x,
                                    y: this.position.y - other.position.y
                                };
                                // Fix division by zero that causes NaN!
                                if (dist > 0) {
                                    separation.x += diff.x / dist;
                                    separation.y += diff.y / dist;
                                }
                            }
                            
                            total++;
                        }
                    }
                });

                if (total > 0) {
                    alignment.x /= total;
                    alignment.y /= total;
                    cohesion.x = cohesion.x / total - this.position.x;
                    cohesion.y = cohesion.y / total - this.position.y;
                }

                // Apply forces (magnet force overrides others when active)
                if (isMagnetActive && (magnetForce.x !== 0 || magnetForce.y !== 0)) {
                    // When magnet is active, reduce other forces
                    this.acceleration.x = magnetForce.x + 
                        alignment.x * 0.02 + 
                        cohesion.x * 0.01 + 
                        separation.x * 0.05 + 
                        flee.x * 0.1;
                    this.acceleration.y = magnetForce.y + 
                        alignment.y * 0.02 + 
                        cohesion.y * 0.01 + 
                        separation.y * 0.05 + 
                        flee.y * 0.1;
                } else {
                    // Normal behavior
                    this.acceleration.x = alignment.x * 0.1 + cohesion.x * 0.05 + separation.x * 0.15 + flee.x;
                    this.acceleration.y = alignment.y * 0.1 + cohesion.y * 0.05 + separation.y * 0.15 + flee.y;
                }

                // Update velocity and position
                this.velocity.x += this.acceleration.x;
                this.velocity.y += this.acceleration.y;
                
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                const maxSpeedAdjusted = isMagnetActive ? this.maxSpeed * 2 : this.maxSpeed;
                if (speed > maxSpeedAdjusted) {
                    this.velocity.x = (this.velocity.x / speed) * maxSpeedAdjusted;
                    this.velocity.y = (this.velocity.y / speed) * maxSpeedAdjusted;
                }

                // Update rotation based on velocity if moving
                if (this.velocity.x !== 0 || this.velocity.y !== 0) {
                    this.rotation = Math.atan2(this.velocity.y, this.velocity.x) + Math.PI / 2; // +90¬∞ so "up" points forward
                }
                
                // Check for nearby food
                foods.forEach((food, index) => {
                    if (food.age > food.lifespan) return; // Skip expired food
                    
                    const dist = Math.sqrt(
                        (this.position.x - food.x) ** 2 + 
                        (this.position.y - food.y) ** 2
                    );
                    
                    if (dist < 15) { // Close enough to eat
                        // Eat the food!
                        accumulateNutrients(this, food.nutrients);
                        foods.splice(index, 1); // Remove eaten food
                        
                        wizzyLog('random', `${this.wizzy} ate ${food.emoji} ${food.name}! Yum! üòã`, 'üçΩÔ∏è');
                        playSound('ambient', 0.8);
                        
                        // Gain some energy from eating
                        if (this.nutrients['‚ö°']) {
                            this.nutrients['‚ö°'] = Math.min(100, this.nutrients['‚ö°'] + 10);
                        }
                    } else if (dist < 50) {
                        // Move towards nearby food
                        // Fix division by zero that causes NaN!
                        if (dist > 0) {
                            const attraction = {
                                x: (food.x - this.position.x) / dist * 0.5,
                                y: (food.y - this.position.y) / dist * 0.5
                            };
                            this.acceleration.x += attraction.x;
                            this.acceleration.y += attraction.y;
                        }
                    }
                });
                
                // Digest nutrients
                digestNutrients(this);
                
                // Auto-poop logic  
                if (globalTime - this.lastAutoPoopTime > poopConfig.autoPoopInterval) {
                    this.poop(false); // Auto poop
                    this.lastAutoPoopTime = globalTime;
                }
                
                // Random events
                if (Math.random() < 0.0005 * actualSpeedMultiplier) {
                    wizzyLog('random', `${this.wizzy} finds cheese! üßÄ`, 'üéâ');
                    playSound('ambient', 0.3);
                }
            }

            draw() {
                if (!this.active || this.caught) return; // Skip inactive or caught mice

                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Draw golden halo if selected (before rotation)
                const scaleFactor = selectedMouse === this ? 1.1 : 1; // Even smaller size increase when selected
                if (selectedMouse === this) {
                    const haloRadius = mouseFeather * 1.3; // Even smaller halo
                    const haloGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, haloRadius);
                    
                    // Much more subtle golden halo
                    haloGradient.addColorStop(0, 'rgba(255, 215, 0, 0)'); // Transparent center
                    haloGradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.1)'); // Very faint gold
                    haloGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.15)'); // Slightly brighter
                    haloGradient.addColorStop(0.8, 'rgba(255, 215, 0, 0.1)'); // Fading
                    haloGradient.addColorStop(1, 'rgba(255, 215, 0, 0)'); // Fully transparent
                    
                    ctx.fillStyle = haloGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, haloRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Apply rotation (always use stored rotation)
                ctx.rotate(this.rotation);

                // Create three-color feathered gradient for fuzzy mouse
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, mouseFeather * scaleFactor);
                
                // Three-color gradient with smooth transitions
                gradient.addColorStop(0, this.colors.inner + 'FF'); // Inner color, full opacity
                gradient.addColorStop(this.middleColorPos * 0.6, this.colors.inner + 'EE');
                gradient.addColorStop(this.middleColorPos, this.colors.middle + 'DD'); // Middle color
                gradient.addColorStop(this.middleColorPos * 1.4, this.colors.middle + 'AA');
                gradient.addColorStop(0.75, this.colors.outer + '77'); // Outer color
                gradient.addColorStop(0.9, this.colors.outer + '33');
                gradient.addColorStop(1, this.colors.outer + '00'); // Fully transparent

                // Draw fuzzy mouse body
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, mouseFeather * scaleFactor, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw status indicator if applicable
                if (this.status === 'droning') {
                    // Special indicator for droning mode - pulsing cyan circle
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3 * scaleFactor;
                    ctx.setLineDash([2 * scaleFactor, 2 * scaleFactor]);
                    ctx.beginPath();
                    ctx.arc(0, 0, mouseFeather * scaleFactor * 1.3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (this.manualControl) {
                    // Temporary control indicator - thin cyan circle
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 1 * scaleFactor;
                    ctx.beginPath();
                    ctx.arc(0, 0, mouseFeather * scaleFactor * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // WIZZY ID label - split into letters and emojis
                const letters = this.wizzy.match(/[A-Z]/g) || [];
                const emojis = this.wizzy.match(/[^\w\s]/g) || [];
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw WIZZY ID as single string (emojis render better this way)
                ctx.font = `bold ${5 * scaleFactor}px Arial`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.shadowBlur = 1 * scaleFactor;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.fillText(this.wizzy, 0, 0);
                
                ctx.restore();
            }
        }

        // Create all owls but only activate the first one
        for (let i = 0; i < 24; i++) {
            const owl = new Owl(i + 1, timeZones[i]);
            if (i < activeOwlCount) {
                owl.active = true;
                wizzyLog('owl', `${owl.wizzy} is active at startup! ü¶â`, '‚ú®');
            }
            owls.push(owl);
        }

        // Create all mice but only activate the first one
        for (let i = 0; i < 200; i++) {
            const mouse = new Mouse(i);
            if (i < activeMouseCount) {
                mouse.active = true;
                wizzyLog('mouse', `${mouse.wizzy} is active at startup! üê≠`, '‚ú®');
            }
            mice.push(mouse);
        }

        // Mouse event handlers - Use global for move/up to never lose tracking
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('click', handleClick);
        // Note: wheel event listener is already added earlier in the code
        
        // Global mouse handlers for robust tracking
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        
        // Canvas-specific handlers
        canvas.addEventListener('mouseleave', handleMouseLeave);
        canvas.addEventListener('mouseenter', handleMouseEnter);
        
        // Prevent default behaviors
        canvas.addEventListener('dragstart', (e) => e.preventDefault());
        canvas.addEventListener('selectstart', (e) => e.preventDefault());
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // UI visibility state
        let uiHidden = false;
        
        // Update keyboard velocity based on pressed keys
        function updateKeyboardVelocity() {
            keyboardScrollVelocity.x = 0;
            keyboardScrollVelocity.y = 0;
            
            // WASD controls panning (normal directions)
            if (keysPressed.has('a') || keysPressed.has('A')) {
                keyboardScrollVelocity.x = -1;  // Reversed from 1
            }
            if (keysPressed.has('d') || keysPressed.has('D')) {
                keyboardScrollVelocity.x = 1;  // Reversed from -1
            }
            if (keysPressed.has('w') || keysPressed.has('W')) {
                keyboardScrollVelocity.y = -1;  // Reversed from 1
            }
            if (keysPressed.has('s') || keysPressed.has('S')) {
                keyboardScrollVelocity.y = 1;  // Reversed from -1
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Prevent key repeat for already pressed keys
            if (keysPressed.has(e.key)) return;
            
            // Add key to pressed set
            keysPressed.add(e.key);
            
            // Tab toggles UI (except minimap)
            if (e.key === 'Tab') {
                e.preventDefault();
                uiHidden = !uiHidden;
                
                // Toggle all UI elements except minimap
                const elementsToToggle = [
                    document.getElementById('stats-panel'),
                    document.getElementById('controls'),
                    document.getElementById('legend'),
                    document.getElementById('info-panel'),
                    document.getElementById('console-log'),
                    document.getElementById('console-toggle-btn')
                ];
                
                elementsToToggle.forEach(el => {
                    if (el) {
                        el.style.display = uiHidden ? 'none' : '';
                    }
                });
                
                // Expand/contract visualization area
                const viz = document.getElementById('visualization');
                if (uiHidden) {
                    viz.style.width = '100%';
                    viz.style.right = '0';
                } else {
                    viz.style.width = '';
                    viz.style.right = '';
                }
                
                // Resize canvas to match new dimensions
                setTimeout(resizeCanvas, 50); // Small delay to ensure CSS changes take effect
                
                wizzyLog('random', uiHidden ? 'UI hidden - zen mode üßò' : 'UI restored üé®', 'üëÅÔ∏è');
                return; // Don't process other Tab key actions
            }
            
            // Spacebar toggles pause
            if (e.key === ' ') {
                e.preventDefault();
                togglePause();
                return;
            }
            
            // ? shows help screen
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                e.preventDefault();
                showHelpScreen();
                return;
            }
            
            // S saves game
            if (e.key === 's' || e.key === 'S') {
                if (e.metaKey || e.ctrlKey) {
                    e.preventDefault();
                    saveState();
                    return;
                }
            }
            
            // L loads game
            if (e.key === 'l' || e.key === 'L') {
                if (e.metaKey || e.ctrlKey) {
                    e.preventDefault();
                    if (confirm('Load saved game? This will replace the current simulation.')) {
                        loadState();
                    }
                    return;
                }
            }
            
            // Escape deselects creature
            if (e.key === 'Escape') {
                e.preventDefault();
                if (selectedOwl) {
                    selectedOwl.manualControl = false;
                    // Exit droning mode when deselected
                    if (selectedOwl.status === 'droning') {
                        selectedOwl.status = 'flying';
                        wizzyLog('owl', `${selectedOwl.wizzy} exits droning mode, returns to flying ü¶Ö`, 'üîÑ');
                    }
                    selectedOwl = null;
                    updateInfoPanel();
                    wizzyLog('owl', 'Released owl control ü¶â', 'üîì');
                } else if (selectedMouse) {
                    selectedMouse.manualControl = false;
                    // Exit droning mode when deselected
                    if (selectedMouse.status === 'droning') {
                        selectedMouse.status = 'foraging';
                        wizzyLog('mouse', `${selectedMouse.wizzy} exits droning mode, returns to foraging üåæ`, 'üîÑ');
                    }
                    selectedMouse = null;
                    updateInfoPanel();
                    wizzyLog('mouse', 'Released mouse control üê≠', 'üîì');
                }
                return;
            }
            
            // \ cycles creature mode
            if (e.key === '\\') {
                e.preventDefault();
                if (selectedOwl) {
                    const modes = ['droning', 'flying', 'hunting', 'resting'];
                    const currentIndex = modes.indexOf(selectedOwl.status);
                    selectedOwl.status = modes[(currentIndex + 1) % modes.length];
                    updateStats();
                    wizzyLog('owl', `${selectedOwl.wizzy} mode changed to ${selectedOwl.status} üîÑ`, '‚ö°');
                } else if (selectedMouse) {
                    const modes = ['droning', 'foraging', 'fleeing'];
                    const currentIndex = modes.indexOf(selectedMouse.status);
                    selectedMouse.status = modes[(currentIndex + 1) % modes.length];
                    updateMouseStats();
                    wizzyLog('mouse', `${selectedMouse.wizzy} mode changed to ${selectedMouse.status} üîÑ`, '‚ö°');
                }
                return;
            }
            
            // Enter key = POOP!
            if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedOwl) {
                    selectedOwl.poop(true);
                    wizzyLog('random', `Manual poop deployed! üí©`, 'üí™');
                } else if (selectedMouse) {
                    selectedMouse.poop(true);
                    wizzyLog('random', `Manual poop deployed! üí©`, 'üí™');
                }
                return;
            }
            
            // Zoom controls
            if (e.key === '=' || e.key === '+' || e.key === '.') {
                // Continuous zoom handled in animation loop
            } else if (e.key === '-' || e.key === '_' || e.key === ',') {
                // Continuous zoom handled in animation loop  
            } else if (e.key === '0') {
                viewScale = 1;
                viewOffset = { x: 0, y: 0 };
                constrainView();
                wizzyLog('random', 'Reset zoom and pan üéØ', 'üîÑ');
            }
            
            // Prevent arrow keys from scrolling the page
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
            }
            
            // Update keyboard scroll velocity based on pressed keys
            updateKeyboardVelocity();
        });
        
        document.addEventListener('keyup', (e) => {
            // Remove key from pressed set
            keysPressed.delete(e.key);
            
            // Update keyboard scroll velocity
            updateKeyboardVelocity();
        });

        // Table event handlers will be set up after DOM is ready in setTimeout below
        
        document.addEventListener('mousemove', (e) => {
            handleTimezoneDrag(e);
            handleEnergyDrag(e);
            handleAltitudeDrag(e);
        });
        document.addEventListener('mouseup', (e) => {
            handleTimezoneDragEnd(e);
            handleEnergyDragEnd(e);
            handleAltitudeDragEnd(e);
        });
        
        // Coordinate transformation helpers
        function screenToWorld(x, y) {
            return {
                x: (x - viewOffset.x) / viewScale,
                y: (y - viewOffset.y) / viewScale
            };
        }
        
        // Center view on a specific world position (instant, no animation)
        function centerViewOn(worldX, worldY) {
            const rect = canvas.getBoundingClientRect();
            viewOffset.x = rect.width / 2 - worldX * viewScale;
            viewOffset.y = rect.height / 2 - worldY * viewScale;
            constrainView();
        }
        
        function worldToScreen(x, y) {
            return {
                x: x * viewScale + viewOffset.x,
                y: y * viewScale + viewOffset.y
            };
        }
        
        function handleWheel(e) {
            e.preventDefault();
            
            // Get zoom sensitivity from slider (default 0.5)
            const sensitivity = parseFloat(document.getElementById('zoomSensitivity')?.value || 0.5);
            
            // Less sensitive zoom with adjustable sensitivity
            const zoomFactor = 1 + (e.deltaY > 0 ? -0.05 : 0.05) * sensitivity;
            const oldScale = viewScale;
            viewScale = Math.max(0.5, Math.min(20, viewScale * zoomFactor));
            
            // Zoom towards mouse position
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            viewOffset.x = mouseX - (mouseX - viewOffset.x) * (viewScale / oldScale);
            viewOffset.y = mouseY - (mouseY - viewOffset.y) * (viewScale / oldScale);
            
            // Apply constraints after zoom
            constrainView();
        }

        function handleTableMouseDown(e) {
            const cell = e.target;
            if (cell.classList.contains('timezone')) {
                e.preventDefault();
                isDraggingTimezone = true;
                timezoneDragTarget = cell.closest('tr');
                timezoneDragStart = e.clientY;
                cell.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
            }
        }

        function handleTimezoneDrag(e) {
            if (!isDraggingTimezone || !timezoneDragTarget) return;
            
            const dragDistance = e.clientY - timezoneDragStart;
            const zonesChanged = Math.floor(dragDistance / 20); // 20 pixels per timezone
            
            if (zonesChanged !== 0) {
                const owlId = parseInt(timezoneDragTarget.dataset.owlId);
                const owl = owls.find(o => o.id === owlId);
                if (owl) {
                    const currentIndex = timeZones.indexOf(owl.timezone);
                    let newIndex = (currentIndex - zonesChanged) % 24;
                    if (newIndex < 0) newIndex += 24;
                    if (newIndex >= 24) newIndex -= 24;
                    
                    owl.setTimezone(timeZones[newIndex]);
                    timezoneDragStart = e.clientY;
                    updateStats();
                }
            }
        }

        function handleTimezoneDragEnd(e) {
            if (isDraggingTimezone) {
                isDraggingTimezone = false;
                timezoneDragTarget = null;
                document.body.style.cursor = '';
                document.querySelectorAll('.timezone.dragging').forEach(el => {
                    el.classList.remove('dragging');
                });
            }
        }
        
        function handleEnergyDragStart(e) {
            e.preventDefault();
            isDraggingEnergy = true;
            energyDragTarget = e.target;
            energyDragStart = e.clientX;
            document.body.style.cursor = 'ew-resize';
            
            // Immediately set energy to clicked position
            const energyBar = energyDragTarget.querySelector('.activity-bar');
            if (energyBar) {
                const rect = energyBar.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
                
                const owlId = parseInt(energyDragTarget.dataset.owlId);
                const owl = owls.find(o => o.id === owlId);
                if (owl) {
                    owl.energy = percentage;
                    updateStats();
                }
            }
        }
        
        function handleAltitudeDragStart(e) {
            e.preventDefault();
            isDraggingAltitude = true;
            altitudeDragTarget = e.target;
            altitudeDragStart = e.clientY;
            document.body.style.cursor = 'ns-resize';
        }
        
        function handleEnergyDrag(e) {
            if (!isDraggingEnergy || !energyDragTarget) return;
            
            // Get the energy bar element and its bounds
            const energyBar = energyDragTarget.querySelector('.activity-bar');
            if (!energyBar) return;
            
            const rect = energyBar.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            // Calculate percentage based on mouse position
            const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
            
            const owlId = parseInt(energyDragTarget.dataset.owlId);
            const owl = owls.find(o => o.id === owlId);
            if (owl) {
                owl.energy = percentage;
                updateStats();
            }
        }
        
        function handleEnergyDragEnd(e) {
            if (isDraggingEnergy) {
                isDraggingEnergy = false;
                energyDragTarget = null;
                document.body.style.cursor = '';
            }
        }
        
        function handleAltitudeDrag(e) {
            if (!isDraggingAltitude || !altitudeDragTarget) return;
            
            const dragDistance = e.clientY - altitudeDragStart;
            const altChange = -dragDistance; // Negative because up is less Y
            
            if (Math.abs(altChange) >= 1) {
                const owlId = parseInt(altitudeDragTarget.dataset.owlId);
                const owl = owls.find(o => o.id === owlId);
                if (owl) {
                    owl.position.z = Math.max(20, Math.min(200, owl.position.z + altChange));
                    altitudeDragStart = e.clientY;
                    updateStats();
                }
            }
        }
        
        function handleAltitudeDragEnd(e) {
            if (isDraggingAltitude) {
                isDraggingAltitude = false;
                altitudeDragTarget = null;
                document.body.style.cursor = '';
            }
        }

        function toggleHeisenbergLogging() {
            heisenbergLoggingEnabled = document.getElementById('heisenberg-logging-enabled').checked;
            // This log will only show if you are enabling it, which is intended.
            wizzyLog('random', `Heisenberg logging ${heisenbergLoggingEnabled ? 'enabled' : 'disabled'} üî¨`, '‚öôÔ∏è');
        }

        function handleOwlTableClick(e) {
            const row = e.target.closest('tr');
            console.log('Owl table clicked', e.target, row); // Debug
            console.log('Row dataset:', row?.dataset); // Debug dataset
            if (row && !isDraggingTimezone && !e.target.classList.contains('timezone')) {
                const owlId = parseInt(row.dataset.owlId);
                console.log('Looking for owl ID:', owlId); // Debug
                console.log('All owls:', owls.map(o => ({id: o.id, wizzy: o.wizzy}))); // Debug
                const owl = owls.find(o => o.id === owlId);
                if (owl) {
                    selectedOwl = selectedOwl === owl ? null : owl;
                    selectedMouse = null;
                    updateInfoPanel();
                    updateStats();
                    wizzyLog('owl', `Selected Owl ${owl.wizzy} üéØ`, 'üëÜ');
                    playSound('select', 0.5);
                } else {
                    console.log('Owl not found with ID:', owlId);
                }
            }
        }

        function handleMouseTableClick(e) {
            const row = e.target.closest('tr');
            if (row) {
                const mouseId = row.dataset.mouseId;
                const mouse = mice.find(m => m.id === mouseId);
                if (mouse && !mouse.caught) {
                    selectedMouse = selectedMouse === mouse ? null : mouse;
                    selectedOwl = null;
                    updateInfoPanel();
                    updateMouseStats();
                    wizzyLog('mouse', `Selected Mouse ${mouse.wizzy} üéØ`, 'üëÜ');
                    playSound('select', 0.5);
                }
            }
        }

        function handleMouseDown(e) {
            e.preventDefault(); // Prevent text selection
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Pan with right click or middle click
            if (e.button === 2 || e.button === 1) {
                isPanning = true;
                panStart.x = x - viewOffset.x;
                panStart.y = y - viewOffset.y;
                canvas.style.cursor = 'move';
                return;
            }
            
            // Transform to world coordinates
            const world = screenToWorld(x, y);

            // Check if clicking on an owl
            for (let i = owls.length - 1; i >= 0; i--) {
                if (owls[i].active && owls[i].isPointInside(world.x, world.y)) {
                    isDragging = true;
                    dragTarget = owls[i];
                    const pos = owls[i].getScreenPosition();
                    dragOffset.x = world.x - pos.x;
                    dragOffset.y = world.y - pos.y;
                    canvas.style.cursor = 'grabbing';
                    
                    // Initialize throwing physics
                    throwVelocityHistory = [];
                    lastMousePos = { x: x, y: y };
                    lastMouseTime = Date.now();
                    
                    playSound('pickup', 0.7);
                    wizzyLog('owl', `Picked up ${owls[i].wizzy} ü§è`, '‚¨ÜÔ∏è');
                    return;
                }
            }

            // Check if clicking on a mouse
            for (let i = mice.length - 1; i >= 0; i--) {
                if (mice[i].active && !mice[i].caught && mice[i].isPointInside(world.x, world.y)) {
                    isDragging = true;
                    dragTarget = mice[i];
                    dragOffset.x = world.x - mice[i].position.x;
                    dragOffset.y = world.y - mice[i].position.y;
                    canvas.style.cursor = 'grabbing';
                    
                    // Initialize throwing physics
                    throwVelocityHistory = [];
                    lastMousePos = { x: x, y: y };
                    lastMouseTime = Date.now();
                    
                    playSound('pickup', 0.5);
                    wizzyLog('mouse', `Picked up ${mice[i].wizzy} ü§è`, '‚¨ÜÔ∏è');
                    return;
                }
            }

            // If clicking on empty space, activate mouse magnet
            isMagnetActive = true;
            magnetPosition.x = world.x;
            magnetPosition.y = world.y;
            // Set color based on attraction/repulsion
            if (magnetStrength < 0) {
                magnetCircle.style.borderColor = '#ff6666';
                magnetCircleInner.style.borderColor = '#ff6666';
            } else {
                magnetCircle.style.borderColor = '#66ff66';
                magnetCircleInner.style.borderColor = '#66ff66';
            }
            updateMagnetCircle();
            playSound('magnetOn', 0.6);
            wizzyLog('mouse', `Mouse magnet activated at (${Math.round(world.x)}, ${Math.round(world.y)}) üß≤`, '‚ö°');
        }

        function handleMouseMove(e) {
            // Get canvas rect fresh each time in case it moved
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Track mouse velocity for throwing physics
            const currentTime = Date.now();
            const currentPos = { x: x, y: y };
            
            // Update velocity history if we have a previous position
            if (lastMousePos.x !== 0 || lastMousePos.y !== 0) {
                const deltaTime = currentTime - lastMouseTime;
                if (deltaTime > 0) {
                    const velocity = {
                        x: (currentPos.x - lastMousePos.x) / deltaTime * 1000, // pixels per second
                        y: (currentPos.y - lastMousePos.y) / deltaTime * 1000,
                        time: currentTime
                    };
                    
                    throwVelocityHistory.push(velocity);
                    
                    // Keep only recent history
                    if (throwVelocityHistory.length > VELOCITY_HISTORY_SIZE) {
                        throwVelocityHistory.shift();
                    }
                }
            }
            
            lastMousePos = currentPos;
            lastMouseTime = currentTime;
            
            // NEVER skip if we're actively dragging/panning/using magnet!
            const isActiveInteraction = isDragging || isPanning || isMagnetActive;
            
            // Skip if mouse is outside canvas (except when actively interacting)
            if (!isActiveInteraction && 
                (x < 0 || x > rect.width || y < 0 || y > rect.height)) {
                return;
            }
            
            if (isPanning) {
                viewOffset.x = x - panStart.x;
                viewOffset.y = y - panStart.y;
                return;
            }
            
            const world = screenToWorld(x, y);

            if (isDragging && dragTarget) {
                if (dragTarget instanceof Owl) {
                    // Store previous position for rotation calculation
                    const prevX = dragTarget.position.x;
                    const prevY = dragTarget.position.y;
                    
                    // Update owl position (maintain altitude)
                    dragTarget.position.x = world.x - dragOffset.x;
                    dragTarget.position.y = world.y - dragOffset.y + dragTarget.position.z / 2;
                    
                    // Calculate movement delta
                    const deltaX = dragTarget.position.x - prevX;
                    const deltaY = dragTarget.position.y - prevY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Always update rotation based on movement
                    const targetRotation = Math.atan2(deltaY, deltaX) + Math.PI / 2; // +90¬∞ so "up" points forward
                    const ROTATION_SMOOTHING = 0.15; // 0-1, lower = smoother
                    smoothRotateTowards(dragTarget, targetRotation, ROTATION_SMOOTHING);
                    
                    // Clear velocity when dragging
                    dragTarget.velocity.x = 0;
                    dragTarget.velocity.y = 0;
                    dragTarget.velocity.z = 0;
                } else if (dragTarget instanceof Mouse) {
                    // Store previous position for rotation calculation
                    const prevX = dragTarget.position.x;
                    const prevY = dragTarget.position.y;
                    
                    // Update mouse position
                    dragTarget.position.x = world.x - dragOffset.x;
                    dragTarget.position.y = world.y - dragOffset.y;
                    
                    // Calculate movement delta
                    const deltaX = dragTarget.position.x - prevX;
                    const deltaY = dragTarget.position.y - prevY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Always update rotation based on movement
                    const targetRotation = Math.atan2(deltaY, deltaX) + Math.PI / 2; // +90¬∞ so "up" points forward
                    const ROTATION_SMOOTHING = 0.15; // 0-1, lower = smoother
                    smoothRotateTowards(dragTarget, targetRotation, ROTATION_SMOOTHING);
                    
                    // Clear velocity when dragging
                    dragTarget.velocity.x = 0;
                    dragTarget.velocity.y = 0;
                }
            }
            
            // Calculate edge scrolling for ANY dragging mode
            if (isDragging || isMagnetActive) {
                autoScrollVelocity = { x: 0, y: 0 };
                
                // Clamp coordinates to canvas bounds for edge detection
                const clampedX = Math.max(0, Math.min(rect.width, x));
                const clampedY = Math.max(0, Math.min(rect.height, y));
                
                // Left edge
                if (clampedX < EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.x = (1 - clampedX / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                // Right edge
                else if (clampedX > rect.width - EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.x = -((clampedX - (rect.width - EDGE_SCROLL_ZONE)) / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                
                // Top edge
                if (clampedY < EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.y = (1 - clampedY / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                // Bottom edge
                else if (clampedY > rect.height - EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.y = -((clampedY - (rect.height - EDGE_SCROLL_ZONE)) / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                
                // Update edge indicators when dragging
                updateEdgeIndicators();
            }
            
            if (isMagnetActive) {
                // Update magnet position
                magnetPosition.x = world.x;
                magnetPosition.y = world.y;
                updateMagnetCircle();
                
                // Calculate edge scrolling
                autoScrollVelocity = { x: 0, y: 0 };
                const rect = canvas.getBoundingClientRect();
                
                // Left edge
                if (x < EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.x = (1 - x / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                // Right edge
                else if (x > rect.width - EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.x = -((x - (rect.width - EDGE_SCROLL_ZONE)) / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                
                // Top edge
                if (y < EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.y = (1 - y / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                // Bottom edge
                else if (y > rect.height - EDGE_SCROLL_ZONE) {
                    autoScrollVelocity.y = -((y - (rect.height - EDGE_SCROLL_ZONE)) / EDGE_SCROLL_ZONE) * MAX_SCROLL_SPEED;
                }
                
                // Update edge indicators
                updateEdgeIndicators();
            } else {
                // Update hover state and cursor
                let foundEntity = false;
                
                // Check owls
                for (let i = owls.length - 1; i >= 0; i--) {
                    if (owls[i].active && owls[i].isPointInside(world.x, world.y)) {
                        canvas.style.cursor = 'grab';
                        foundEntity = true;
                        break;
                    }
                }
                
                // Check mice if no owl found
                if (!foundEntity) {
                    for (let i = mice.length - 1; i >= 0; i--) {
                        if (mice[i].active && !mice[i].caught && mice[i].isPointInside(world.x, world.y)) {
                            canvas.style.cursor = 'grab';
                            foundEntity = true;
                            break;
                        }
                    }
                }
                
                if (!foundEntity) {
                    canvas.style.cursor = 'crosshair';
                }
                
                // Clear edge indicators when not dragging
                if (!isDragging && !isMagnetActive) {
                    autoScrollVelocity = { x: 0, y: 0 };
                    updateEdgeIndicators();
                }
            }
        }

        function handleMouseUp(e) {
            if (isDragging && dragTarget) {
                // Calculate throwing velocity from recent mouse movement
                if (throwVelocityHistory.length > 0) {
                    // Average recent velocities for smoother throwing
                    let avgVelX = 0, avgVelY = 0;
                    throwVelocityHistory.forEach(vel => {
                        avgVelX += vel.x;
                        avgVelY += vel.y;
                    });
                    avgVelX /= throwVelocityHistory.length;
                    avgVelY /= throwVelocityHistory.length;
                    
                    // Convert screen velocity to world velocity  
                    const worldVelX = avgVelX / viewScale * THROW_VELOCITY_SCALE;
                    const worldVelY = avgVelY / viewScale * THROW_VELOCITY_SCALE;
                    const throwSpeed = Math.sqrt(worldVelX * worldVelX + worldVelY * worldVelY);
                    
                    // Apply throwing velocity in the direction the creature is facing
                    if (throwSpeed > 1) { // Only throw if there's significant velocity
                        const facingX = Math.sin(dragTarget.rotation);
                        const facingY = -Math.cos(dragTarget.rotation);
                        
                        if (dragTarget instanceof Owl) {
                            dragTarget.velocity.x = facingX * throwSpeed;
                            dragTarget.velocity.y = facingY * throwSpeed;
                            dragTarget.velocity.z = Math.abs(throwSpeed) * 0.3; // Add some altitude
                            wizzyLog('owl', `Threw ${dragTarget.wizzy} at ${throwSpeed.toFixed(1)} speed! üöÄ`, 'üí®');
                        } else if (dragTarget instanceof Mouse) {
                            dragTarget.velocity.x = facingX * throwSpeed;
                            dragTarget.velocity.y = facingY * throwSpeed;
                            wizzyLog('mouse', `Threw ${dragTarget.wizzy} at ${throwSpeed.toFixed(1)} speed! üöÄ`, 'üí®');
                        }
                        
                        playSound('drop', 0.8); // Louder sound for throwing
                    } else {
                        playSound('drop', 0.5);
                        if (dragTarget instanceof Owl) {
                            wizzyLog('owl', `Dropped ${dragTarget.wizzy} ü§ö`, '‚¨áÔ∏è');
                        } else if (dragTarget instanceof Mouse) {
                            wizzyLog('mouse', `Dropped ${dragTarget.wizzy} ü§ö`, '‚¨áÔ∏è');
                        }
                    }
                } else {
                    playSound('drop', 0.5);
                    if (dragTarget instanceof Owl) {
                        wizzyLog('owl', `Dropped ${dragTarget.wizzy} ü§ö`, '‚¨áÔ∏è');
                    } else if (dragTarget instanceof Mouse) {
                        wizzyLog('mouse', `Dropped ${dragTarget.wizzy} ü§ö`, '‚¨áÔ∏è');
                    }
                }
                
                // Clear velocity history for next throw
                throwVelocityHistory = [];
            }
            if (isMagnetActive) {
                playSound('magnetOff', 0.4);
            }
            
            isDragging = false;
            dragTarget = null;
            isMagnetActive = false;
            isPanning = false;
            autoScrollVelocity = { x: 0, y: 0 };
            updateEdgeIndicators();
            canvas.style.cursor = 'crosshair';
            magnetCircle.classList.remove('active');
            magnetCircle.style.animation = 'none';
            magnetCircle.style.opacity = '0';
            magnetCircleInner.classList.remove('active');
            magnetCircleInner.style.animation = 'none';
            magnetCircleInner.style.opacity = '0';
            magnetCircleInner.style.display = 'none';
        }

        function handleMouseLeave(e) {
            // DO NOT CANCEL DRAGGING WHEN MOUSE LEAVES!
            // Only reset non-dragging states
            if (!isDragging && !isMagnetActive) {
                isPanning = false;
                autoScrollVelocity = { x: 0, y: 0 };
                updateEdgeIndicators();
                canvas.style.cursor = 'crosshair';
            }
        }

        function handleMouseEnter(e) {
            // Reset cursor when re-entering canvas
            if (!isDragging && !isPanning && !isMagnetActive) {
                canvas.style.cursor = 'crosshair';
            }
        }

        function handleClick(e) {
            if (isDragging || isMagnetActive) return; // Don't select if we were dragging or using magnet

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);

            // Check if clicking on an owl
            for (let i = owls.length - 1; i >= 0; i--) {
                if (owls[i].active && owls[i].isPointInside(world.x, world.y)) {
                    selectedOwl = selectedOwl === owls[i] ? null : owls[i];
                    selectedMouse = null;
                    updateInfoPanel();
                    updateStats();
                    wizzyLog('owl', selectedOwl ? `Selected ${owls[i].wizzy} üéØ` : `Deselected ${owls[i].wizzy} ‚ùå`, 'üëÜ');
                    playSound('select', 0.5);
                    
                    // Scroll to owl in table if owls tab is active
                    if (currentTab === 'owls' && selectedOwl) {
                        scrollToTableRow(owls[i].id, 'owl');
                    }
                    return;
                }
            }

            // Check if clicking on a mouse
            for (let i = mice.length - 1; i >= 0; i--) {
                if (mice[i].active && !mice[i].caught && mice[i].isPointInside(world.x, world.y)) {
                    selectedMouse = selectedMouse === mice[i] ? null : mice[i];
                    selectedOwl = null;
                    updateInfoPanel();
                    updateMouseStats();
                    wizzyLog('mouse', selectedMouse ? `Selected ${mice[i].wizzy} üéØ` : `Deselected ${mice[i].wizzy} ‚ùå`, 'üëÜ');
                    playSound('select', 0.5);
                    
                    // Scroll to mouse in table if mice tab is active
                    if (currentTab === 'mice' && selectedMouse) {
                        scrollToTableRow(mice[i].id, 'mouse');
                    }
                    return;
                }
            }

            // Click on empty space - deselect
            selectedOwl = null;
            selectedMouse = null;
            updateInfoPanel();
            updateStats();
            updateMouseStats();
        }

        function updateMagnetCircle() {
            const radius = parseFloat(document.getElementById('magnetRadius').value);
            const screenPos = worldToScreen(magnetPosition.x, magnetPosition.y);
            magnetCircle.style.width = radius * 2 * viewScale + 'px';
            magnetCircle.style.height = radius * 2 * viewScale + 'px';
            magnetCircle.style.left = (screenPos.x - radius * viewScale) + 'px';
            magnetCircle.style.top = (screenPos.y - radius * viewScale) + 'px';
            
            // Dynamic animation speed based on magnet strength
            const baseSpeed = 10; // seconds for full rotation at strength 1
            const speed = Math.abs(magnetStrength) > 0 ? baseSpeed / Math.abs(magnetStrength) : baseSpeed;
            const direction = magnetStrength < 0 ? 'normal' : 'reverse'; // Repel = clockwise, Attract = counter-clockwise
            magnetCircle.style.animation = `pulse 1s ease-in-out infinite, rotateDashes ${speed}s linear infinite ${direction}`;
            magnetCircle.style.borderWidth = '4px';
            magnetCircle.style.borderStyle = 'dashed';
            magnetCircle.style.setProperty('border-dasharray', '10 80'); // Fewer dashes, much bigger gaps
            
            magnetCircle.classList.add('active');
            
            // Update inner neutral zone circle
            const neutralRadius = radius * (magnetNeutralZone / 100);
            if (magnetNeutralZone > 0) {
                magnetCircleInner.style.width = neutralRadius * 2 * viewScale + 'px';
                magnetCircleInner.style.height = neutralRadius * 2 * viewScale + 'px';
                magnetCircleInner.style.left = (screenPos.x - neutralRadius * viewScale) + 'px';
                magnetCircleInner.style.top = (screenPos.y - neutralRadius * viewScale) + 'px';
                magnetCircleInner.style.display = 'block';
                
                // Same dynamic animation but opposite direction
                const innerSpeed = Math.abs(magnetStrength) > 0 ? baseSpeed / Math.abs(magnetStrength) : baseSpeed;
                const innerDirection = magnetStrength < 0 ? 'reverse' : 'normal'; // Opposite of outer
                magnetCircleInner.style.animation = `pulse 1s ease-in-out infinite, rotateDashesReverse ${innerSpeed}s linear infinite ${innerDirection}`;
                magnetCircleInner.style.borderWidth = '4px';
                magnetCircleInner.style.borderStyle = 'dashed';
                magnetCircleInner.style.setProperty('border-dasharray', '10 80'); // Fewer dashes, much bigger gaps
                
                magnetCircleInner.classList.add('active');
            } else {
                magnetCircleInner.style.display = 'none';
            }
        }

        function updateInfoPanel() {
            if (!selectedOwl && !selectedMouse) {
                infoPanel.classList.remove('active');
                return;
            }

            let html = '';
            
            if (selectedOwl) {
                const successRate = selectedOwl.attempts > 0 
                    ? Math.round((selectedOwl.catches / selectedOwl.attempts) * 100) 
                    : 0;
                
                html = `
                    <div class="info-title">Owl ${selectedOwl.wizzy} (#${selectedOwl.id})</div>
                    <div class="info-row">
                        <span class="info-label">Time Zone:</span>
                        <span class="info-value">${selectedOwl.timezone}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Local Time:</span>
                        <span class="info-value">${selectedOwl.getFormattedLocalTime()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value">${selectedOwl.status}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Altitude:</span>
                        <span class="info-value">${Math.round(selectedOwl.position.z)}m</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Energy:</span>
                        <span class="info-value">${Math.round(selectedOwl.energy)}%</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Catches:</span>
                        <span class="info-value">${selectedOwl.catches}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Success Rate:</span>
                        <span class="info-value">${successRate}%</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Active Period:</span>
                        <span class="info-value">${selectedOwl.isActiveTime() ? 'Yes' : 'No'}</span>
                    </div>
                `;
            } else if (selectedMouse) {
                const speed = Math.sqrt(
                    selectedMouse.velocity.x ** 2 + 
                    selectedMouse.velocity.y ** 2
                ).toFixed(1);
                
                html = `
                    <div class="info-title">Mouse ${selectedMouse.wizzy}</div>
                    <div class="info-row">
                        <span class="info-label">Position:</span>
                        <span class="info-value">${Math.round(selectedMouse.position.x)}, ${Math.round(selectedMouse.position.y)}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Speed:</span>
                        <span class="info-value">${speed}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value">${selectedMouse.caught ? 'Caught' : 'Alive'}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Close Calls:</span>
                        <span class="info-value">${selectedMouse.closeCallCount}</span>
                    </div>
                `;
            }

            infoPanel.innerHTML = html;
            infoPanel.style.left = '20px';
            infoPanel.style.bottom = '90px';
            infoPanel.classList.add('active');
        }

        // Tab switching
        function switchTab(tab) {
            currentTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            
            // Update appropriate stats
            if (tab === 'mice') {
                updateMouseStats();
            } else if (tab === 'stats') {
                updateGlobalStats();
            } else if (tab === 'inspector') {
                updateInspector();
            }
            
            wizzyLog('random', `Switched to ${tab} tab üìë`, 'üîÑ');
        }
        
        // Inspector function to display all nutrient bags
        function updateInspector() {
            const content = document.getElementById('inspector-content');
            content.innerHTML = '';
            
            // Helper to format nutrient value
            function formatNutrient(value) {
                if (typeof value === 'number') {
                    return value.toFixed(1);
                } else if (Array.isArray(value)) {
                    return `[${value.length}] ${value.slice(0, 5).join(', ')}${value.length > 5 ? '...' : ''}`;
                } else if (typeof value === 'string') {
                    return `"${value}"`;
                } else {
                    return JSON.stringify(value);
                }
            }
            
            // Create section for each type
            const sections = [];
            
            // Owls section
            const activeOwls = owls.filter(o => o.active);
            if (activeOwls.length > 0) {
                let owlHtml = '<div style="margin: 10px 0;"><h4>ü¶â Owls</h4>';
                activeOwls.forEach(owl => {
                    owlHtml += `<div style="margin: 5px 0; padding: 5px; background: #2a2a2a; border-radius: 4px;">`;
                    owlHtml += `<strong>${owl.wizzy}</strong> (${owl.status}):<br>`;
                    for (const [key, value] of Object.entries(owl.nutrients)) {
                        owlHtml += `<span style="margin-left: 20px;">${key}: ${formatNutrient(value)}</span><br>`;
                    }
                    owlHtml += '</div>';
                });
                owlHtml += '</div>';
                sections.push(owlHtml);
            }
            
            // Mice section
            const activeMice = mice.filter(m => m.active && !m.caught);
            if (activeMice.length > 0) {
                let mouseHtml = '<div style="margin: 10px 0;"><h4>üê≠ Mice</h4>';
                activeMice.forEach(mouse => {
                    mouseHtml += `<div style="margin: 5px 0; padding: 5px; background: #2a2a2a; border-radius: 4px;">`;
                    mouseHtml += `<strong>${mouse.wizzy}</strong> (${mouse.status}):<br>`;
                    for (const [key, value] of Object.entries(mouse.nutrients)) {
                        mouseHtml += `<span style="margin-left: 20px;">${key}: ${formatNutrient(value)}</span><br>`;
                    }
                    mouseHtml += '</div>';
                });
                mouseHtml += '</div>';
                sections.push(mouseHtml);
            }
            
            // Poops section
            if (poops.length > 0) {
                let poopHtml = '<div style="margin: 10px 0;"><h4>üí© Poops</h4>';
                poops.slice(-10).forEach((poop, index) => { // Show last 10 poops
                    poopHtml += `<div style="margin: 5px 0; padding: 5px; background: #2a2a2a; border-radius: 4px;">`;
                    poopHtml += `<strong>Poop #${poops.length - 10 + index}</strong> from ${poop.creatureId} (${poop.creatureType}):<br>`;
                    poopHtml += `Age: ${(poop.age / 1000).toFixed(1)}s / ${(poop.fadeAge / 1000).toFixed(1)}s<br>`;
                    for (const [key, value] of Object.entries(poop.nutrients)) {
                        poopHtml += `<span style="margin-left: 20px;">${key}: ${formatNutrient(value)}</span><br>`;
                    }
                    poopHtml += '</div>';
                });
                poopHtml += '</div>';
                sections.push(poopHtml);
            }
            
            // Foods section
            if (foods.length > 0) {
                let foodHtml = '<div style="margin: 10px 0;"><h4>üçÑ Foods</h4>';
                foods.slice(-10).forEach((food, index) => { // Show last 10 foods
                    foodHtml += `<div style="margin: 5px 0; padding: 5px; background: #2a2a2a; border-radius: 4px;">`;
                    foodHtml += `<strong>${food.emoji} ${food.name}</strong>:<br>`;
                    foodHtml += `Age: ${(food.age / 1000).toFixed(1)}s<br>`;
                    for (const [key, value] of Object.entries(food.nutrients)) {
                        foodHtml += `<span style="margin-left: 20px;">${key}: ${formatNutrient(value)}</span><br>`;
                    }
                    foodHtml += '</div>';
                });
                foodHtml += '</div>';
                sections.push(foodHtml);
            }
            
            // Summary stats
            let summaryHtml = '<div style="margin: 10px 0; padding: 10px; background: #1a1a1a; border-radius: 4px;">';
            summaryHtml += '<h4>üìä Summary</h4>';
            summaryHtml += `Active Owls: ${activeOwls.length}<br>`;
            summaryHtml += `Active Mice: ${activeMice.length}<br>`;
            summaryHtml += `Total Poops: ${poops.length}<br>`;
            summaryHtml += `Total Foods: ${foods.length}<br>`;
            summaryHtml += '</div>';
            
            content.innerHTML = summaryHtml + sections.join('');
        }

        // Update stats table
        function updateStats() {
            const tbody = document.getElementById('owl-stats');
            tbody.innerHTML = '';

            let totalCatches = 0;
            let totalAttempts = 0;
            let activeHunters = 0;
            let topHunter = { id: '-', catches: 0 };

            owls.forEach(owl => {
                // Skip inactive owls unless they're selected
                if (!owl.active && owl !== selectedOwl) return;
                
                const localTime = owl.getFormattedLocalTime();
                
                // Only count stats for active owls
                if (owl.active) {
                    totalCatches += owl.catches;
                    totalAttempts += owl.attempts;
                    if (owl.status === 'hunting') activeHunters++;
                    
                    if (owl.catches > topHunter.catches) {
                        topHunter = { id: owl.id, catches: owl.catches };
                    }
                }

                const row = document.createElement('tr');
                row.dataset.owlId = owl.id;
                if (selectedOwl === owl) {
                    row.classList.add('selected');
                }
                if (!owl.active) {
                    row.style.opacity = '0.3';
                    row.style.backgroundColor = '#111';
                }
                
                row.innerHTML = `
                    <td class="owl-id">${owl.id}</td>
                    <td class="col-wizzy wizzy-button" data-owl-id="${owl.id}" title="Click to select owl ${owl.wizzy}">${owl.wizzy}</td>
                    <td class="timezone" title="Drag up/down to change timezone">${owl.timezone}</td>
                    <td class="local-time" title="Local time for ${owl.wizzy}">${localTime}</td>
                    <td class="owl-status ${owl.status}" data-owl-id="${owl.id}" title="Click to toggle hunting/resting">${owl.status}</td>
                    <td class="owl-altitude" data-owl-id="${owl.id}" title="Drag up/down to change altitude (20-200m)">${Math.round(owl.position.z)}m</td>
                    <td title="${owl.catches} successful catches">${owl.catches}</td>
                    <td title="${owl.attempts} hunting attempts">${owl.attempts}</td>
                    <td class="owl-energy" data-owl-id="${owl.id}" title="Click or drag to set energy level">
                        <div class="activity-bar">
                            <div class="activity-fill" style="width: ${owl.energy}%"></div>
                        </div>
                    </td>
                    <td title="${owl.isActiveTime() ? 'Night time - active' : 'Day time - resting'}">${owl.isActiveTime() ? 'üåô' : '‚òÄÔ∏è'}</td>
                `;
                tbody.appendChild(row);
            });

            // Update summary stats
            const remainingMice = mice.filter(m => m.active && !m.caught).length;
            document.getElementById('mice-count').textContent = remainingMice;
            document.getElementById('active-hunters').textContent = activeHunters;
            document.getElementById('avg-success').textContent = 
                totalAttempts > 0 ? Math.round((totalCatches / totalAttempts) * 100) + '%' : '0%';
            document.getElementById('top-hunter').textContent = 
                topHunter.id === '-' ? '-' : `${owls.find(o => o.id === topHunter.id && o.active)?.wizzy || '-'} (${topHunter.catches})`;
        }

        // Update mouse stats
        function updateMouseStats() {
            const tbody = document.getElementById('mouse-stats');
            tbody.innerHTML = '';

            mice.forEach(mouse => {
                if (mouse.active || selectedMouse === mouse) { // Show active mice and selected mouse
                    const speed = Math.sqrt(
                        mouse.velocity.x ** 2 + 
                        mouse.velocity.y ** 2
                    ).toFixed(1);
                    
                    const predator = mouse.caughtBy ? owls.find(o => o.id === mouse.caughtBy)?.wizzy || `#${mouse.caughtBy}` : '-';
                    
                    const row = document.createElement('tr');
                    row.dataset.mouseId = mouse.id;
                    if (selectedMouse === mouse) {
                        row.classList.add('selected');
                    }
                    if (!mouse.active) {
                        row.style.opacity = '0.3';
                        row.style.backgroundColor = '#111';
                    }
                    
                    row.innerHTML = `
                        <td class="col-id">${mice.indexOf(mouse) + 1}</td>
                        <td class="col-wizzy wizzy-button" data-mouse-id="${mouse.id}" title="Click to select mouse ${mouse.wizzy}">${mouse.wizzy}</td>
                        <td>${Math.round(mouse.position.x)}, ${Math.round(mouse.position.y)}</td>
                        <td>${speed}</td>
                        <td>${mouse.caught ? 'Caught' : 'Alive'}</td>
                        <td>${predator}</td>
                        <td>${mouse.poopCount} üí©</td>
                    `;
                    tbody.appendChild(row);
                }
            });
        }

        // Update global stats
        function updateGlobalStats() {
            const time = formatTime(globalTime);
            document.getElementById('stat-sim-time').textContent = 
                `Day ${time.days + 1}, ${time.formatted}`;
            
            document.getElementById('stat-total-hunts').textContent = globalStats.totalHunts;
            document.getElementById('stat-success-rate').textContent = 
                globalStats.totalHunts > 0 
                    ? Math.round((globalStats.successfulHunts / globalStats.totalHunts) * 100) + '%'
                    : '0%';
            
            const caughtMice = mice.filter(m => m.active && m.caught).length;
            const totalActiveMice = mice.filter(m => m.active).length;
            document.getElementById('stat-mice-caught').textContent = caughtMice;
            
            // Best hunter (among active owls)
            const activeOwls = owls.filter(owl => owl.active);
            let bestHunter = activeOwls[0] || { wizzy: '-', catches: 0 };
            activeOwls.forEach(owl => {
                if (owl.catches > bestHunter.catches) bestHunter = owl;
            });
            document.getElementById('stat-best-hunter').textContent = 
                bestHunter.wizzy === '-' ? '-' : `${bestHunter.wizzy} (${bestHunter.catches})`;
            
            // Most active (among active owls)
            let mostActive = activeOwls[0] || { wizzy: '-', attempts: 0 };
            activeOwls.forEach(owl => {
                if (owl.attempts > mostActive.attempts) mostActive = owl;
            });
            document.getElementById('stat-most-active').textContent = 
                mostActive.wizzy === '-' ? '-' : `${mostActive.wizzy} (${mostActive.attempts})`;
            
            // Average energy (of active owls)
            const avgEnergy = activeOwls.length > 0 
                ? activeOwls.reduce((sum, owl) => sum + owl.energy, 0) / activeOwls.length
                : 0;
            document.getElementById('stat-avg-energy').textContent = Math.round(avgEnergy) + '%';
            
            // Night owls (among active owls)
            const nightOwls = owls.filter(owl => owl.active && owl.isActiveTime()).length;
            document.getElementById('stat-night-owls').textContent = nightOwls;
            
            // Mouse survival
            const survivalRate = totalActiveMice > 0 ? ((totalActiveMice - caughtMice) / totalActiveMice * 100).toFixed(1) : '100.0';
            document.getElementById('stat-survival-rate').textContent = survivalRate + '%';
            
            // Average mouse speed
            let totalSpeed = 0;
            let aliveCount = 0;
            mice.forEach(mouse => {
                if (mouse.active && !mouse.caught) {
                    const speed = Math.sqrt(mouse.velocity.x ** 2 + mouse.velocity.y ** 2);
                    totalSpeed += speed;
                    aliveCount++;
                }
            });
            const avgSpeed = aliveCount > 0 ? (totalSpeed / aliveCount).toFixed(1) : '0.0';
            document.getElementById('stat-avg-mouse-speed').textContent = avgSpeed;
            
            document.getElementById('stat-close-calls').textContent = globalStats.closeCalls;
            
            // Total poops (active mice only)
            const totalPoops = mice.filter(m => m.active).reduce((sum, mouse) => sum + mouse.poopCount, 0);
            document.getElementById('stat-total-poops').textContent = totalPoops + ' üí©';
            
            // Time zone analysis (active owls only)
            let mostActiveZone = { zone: '-', count: 0 };
            const zoneActivity = {};
            owls.forEach(owl => {
                if (!owl.active) return;
                if (!zoneActivity[owl.timezone]) zoneActivity[owl.timezone] = 0;
                zoneActivity[owl.timezone] += owl.catches;
            });
            for (const [zone, count] of Object.entries(zoneActivity)) {
                if (count > mostActiveZone.count) {
                    mostActiveZone = { zone, count };
                }
            }
            document.getElementById('stat-active-tz').textContent = mostActiveZone.zone;
            
            // Peak hour
            let peakHour = { hour: 0, count: 0 };
            globalStats.hourlyHunts.forEach((count, hour) => {
                if (count > peakHour.count) {
                    peakHour = { hour, count };
                }
            });
            document.getElementById('stat-peak-hour').textContent = 
                `${String(peakHour.hour).padStart(2, '0')}:00`;
            
            // Dawn/dusk hunters (active owls only)
            let dawnHunters = 0;
            let duskHunters = 0;
            owls.forEach(owl => {
                if (!owl.active) return;
                const hour = owl.getLocalTime().hours;
                if (hour >= 5 && hour < 7) dawnHunters++;
                if (hour >= 17 && hour < 19) duskHunters++;
            });
            document.getElementById('stat-dawn-hunters').textContent = dawnHunters;
            document.getElementById('stat-dusk-hunters').textContent = duskHunters;
            
            // Poop Analytics
            let totalPoopCount = 0;
            let owlPoopCount = 0;
            let mousePoopCount = 0;
            let fearPoopCount = 0;
            let voluntaryPoopCount = 0;
            let autoPoopCount = 0;
            let totalPoopWeight = 0;
            let highestDrop = 0;
            
            // Count poops by type and source
            poops.forEach(poop => {
                if (poop.age <= poop.fadeAge) { // Only count visible poops
                    totalPoopCount++;
                    totalPoopWeight += poop.weight / 1000; // Convert to kg
                    
                    if (poop.creatureType === 'owl') {
                        owlPoopCount++;
                        // Track highest drop
                        const dropHeight = poop.startY;
                        if (dropHeight > highestDrop) {
                            highestDrop = dropHeight;
                        }
                    } else {
                        mousePoopCount++;
                    }
                    
                    // Count by poop type
                    if (poop.poopType === 'fear') {
                        fearPoopCount++;
                    } else if (poop.poopType === 'voluntary') {
                        voluntaryPoopCount++;
                    } else if (poop.poopType === 'auto') {
                        autoPoopCount++;
                    }
                }
            });
            
            // Update poop stats displays
            document.getElementById('stat-total-poops-global').textContent = totalPoopCount;
            document.getElementById('stat-owl-poops').textContent = owlPoopCount;
            document.getElementById('stat-mouse-poops').textContent = mousePoopCount;
            document.getElementById('stat-fear-poops').textContent = fearPoopCount;
            document.getElementById('stat-voluntary-poops').textContent = voluntaryPoopCount;
            document.getElementById('stat-auto-poops').textContent = autoPoopCount;
            document.getElementById('stat-total-poop-weight').textContent = totalPoopWeight.toFixed(2) + ' kg';
            
            // Average per creature (active only)
            const totalActiveCreatures = activeOwlCount + activeMouseCount;
            const avgPoopPerCreature = totalActiveCreatures > 0 ? 
                (totalPoopCount / totalActiveCreatures).toFixed(1) : '0.0';
            document.getElementById('stat-avg-poop-per-creature').textContent = avgPoopPerCreature;
            
            // Find poop champions
            let topPoopingOwl = { wizzy: '-', count: 0, weight: 0 };
            owls.forEach(owl => {
                if (owl.active && owl.poopCount > topPoopingOwl.count) {
                    topPoopingOwl = { 
                        wizzy: owl.wizzy, 
                        count: owl.poopCount,
                        weight: owl.totalPoopWeight 
                    };
                }
            });
            
            let mostScaredMouse = { wizzy: '-', count: 0 };
            mice.forEach(mouse => {
                if (mouse.active && mouse.poopCount > mostScaredMouse.count) {
                    mostScaredMouse = { 
                        wizzy: mouse.wizzy, 
                        count: mouse.poopCount 
                    };
                }
            });
            
            document.getElementById('stat-top-pooping-owl').textContent = 
                topPoopingOwl.wizzy === '-' ? '-' : 
                `${topPoopingOwl.wizzy} (${topPoopingOwl.count}üí©, ${topPoopingOwl.weight.toFixed(1)}kg)`;
            
            document.getElementById('stat-most-scared-mouse').textContent = 
                mostScaredMouse.wizzy === '-' ? '-' : 
                `${mostScaredMouse.wizzy} (${mostScaredMouse.count}üí©)`;
            
            // Convert highest drop from Y coordinate to approximate altitude
            // Assuming owls fly at 20-200m altitude and canvas height maps to this range
            const estimatedAltitude = Math.round((canvas.height - highestDrop) / canvas.height * 180 + 20);
            document.getElementById('stat-highest-drop').textContent = 
                highestDrop > 0 ? `~${estimatedAltitude}m` : '0m';
            
            // TODO: Track longest poop trail (needs more complex tracking)
            document.getElementById('stat-longest-poop-trail').textContent = '0';
        }
        
        // Update all stats when needed
        function updateAllStats() {
            if (currentTab === 'owls') {
                updateStats();
            } else if (currentTab === 'mice') {
                updateMouseStats();
            } else if (currentTab === 'stats') {
                updateGlobalStats();
            }
        }

        // Scroll table to show selected row
        function scrollToTableRow(entityId, type) {
            const row = type === 'owl' 
                ? document.querySelector(`tr[data-owl-id="${entityId}"]`)
                : document.querySelector(`tr[data-mouse-id="${entityId}"]`);
                
            if (row) {
                const tabContent = row.closest('.tab-content');
                if (tabContent) {
                    const rowTop = row.offsetTop;
                    const rowHeight = row.offsetHeight;
                    const containerTop = tabContent.scrollTop;
                    const containerHeight = tabContent.offsetHeight;
                    
                    // Check if row is not fully visible
                    if (rowTop < containerTop || rowTop + rowHeight > containerTop + containerHeight) {
                        // Scroll to center the row
                        tabContent.scrollTop = rowTop - (containerHeight / 2) + (rowHeight / 2);
                    }
                }
            }
        }

        // Update time display
        function updateTime() {
            const time = formatTime(globalTime);
            document.getElementById('global-time').textContent = 
                `Day ${time.days + 1}, ${time.formatted} UTC`;
                
            // Time-based logging
            if (frameCount % 600 === 0) { // Every ~10 seconds
                wizzyLog('time', `Day ${time.days + 1} at ${time.formatted} UTC ‚è∞`, 'üìÖ');
            }
            
            // Time tick sounds
            if (frameCount % 60 === 0 && actualSpeedMultiplier < 3) { // Every second, not at high speed
                playSound('time', 0.3);
            }
            
            // Ambient sounds
            if (frameCount % 300 === 0 && Math.random() < 0.3) { // Occasionally
                playSound('ambient', 0.5);
            }
        }

        // Speed control
        function updateSpeedDisplay() {
            const sliderValue = parseFloat(document.getElementById('speed').value);
            actualSpeedMultiplier = getSpeedMultiplier(sliderValue);
            document.getElementById('speed-display').textContent = 
                actualSpeedMultiplier < 1 
                    ? actualSpeedMultiplier.toFixed(2) + 'x'
                    : actualSpeedMultiplier.toFixed(1) + 'x';
        }

        // Magnet control
        function updateMagnetDisplay() {
            const slider = document.getElementById('magnetRadius');
            const radius = slider.value;
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = radius + 'px';
            }
        }

        // Zoom control
        function updateZoomDisplay() {
            const slider = document.getElementById('zoomSensitivity');
            const sensitivity = slider.value;
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = sensitivity + 'x';
            }
        }
        
        // Keyboard control displays
        function updateKeyScrollDisplay() {
            const slider = document.getElementById('keyScrollSpeed');
            keyScrollSpeed = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = keyScrollSpeed;
            }
        }
        
        function updateKeyZoomDisplay() {
            const slider = document.getElementById('keyZoomSpeed');
            keyZoomSpeed = parseFloat(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = keyZoomSpeed.toFixed(1);
            }
        }
        
        // Mouse magnet control displays
        function updateMagnetStrength() {
            const slider = document.getElementById('magnet-strength');
            magnetStrength = parseFloat(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                const sign = magnetStrength >= 0 ? '+' : '';
                label.textContent = sign + magnetStrength.toFixed(1) + 'x';
            }
            // Update color based on attraction/repulsion
            if (magnetStrength < 0) {
                magnetCircle.style.borderColor = '#ff6666'; // Red for repulsion
                magnetCircleInner.style.borderColor = '#ff6666';
            } else {
                magnetCircle.style.borderColor = '#66ff66'; // Green for attraction
                magnetCircleInner.style.borderColor = '#66ff66';
            }
            wizzyLog('random', magnetStrength > 0 ? `Magnet attracts at ${magnetStrength.toFixed(1)}x üß≤` : 
                                magnetStrength < 0 ? `Magnet repels at ${Math.abs(magnetStrength).toFixed(1)}x üåÄ` :
                                `Magnet neutralized üòê`, '‚ö°');
        }
        
        function updateMagnetNeutralZone() {
            const slider = document.getElementById('magnet-neutral-zone');
            magnetNeutralZone = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = magnetNeutralZone + '%';
            }
            // Update the circle display if magnet is active
            if (isMagnetActive) {
                updateMagnetCircle();
            }
            wizzyLog('random', `Magnet neutral zone set to ${magnetNeutralZone}% üéØ`, 'üîß');
        }
        
        // Trails control display
        function updateTrailsDisplay() {
            const slider = document.getElementById('trails-fade');
            const sliderValue = parseFloat(slider.value);
            
            // 0% = no trails (fade = 1.0), 100% = full trails (fade near 0)
            // Use exponential decay for natural trail effect
            if (sliderValue === 0) {
                trailsFade = 1.0; // No trails
            } else {
                // Exponential decay: at 50% we want significant trails (fade ~0.1)
                // at 99% we want almost no clearing (fade ~0.001)
                // Using power function to map slider to fade
                const power = 5; // Controls the curve steepness
                trailsFade = Math.pow(1 - sliderValue, power);
                
                // Clamp to minimum to ensure some clearing
                if (trailsFade < 0.001) trailsFade = 0.001;
            }
            
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                // Display slider percentage (0% = no trails, 100% = full trails)
                const percentage = (sliderValue * 100).toFixed(1);
                label.textContent = percentage + '%';
            }
            wizzyLog('random', `Trail effect set to ${(sliderValue * 100).toFixed(1)}% (fade: ${trailsFade.toFixed(4)}) üåà`, '‚ú®');
        }
        
        // Poop control functions
        function updatePoopInterval() {
            const slider = document.getElementById('poop-interval');
            poopConfig.autoPoopInterval = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = (poopConfig.autoPoopInterval / 1000).toFixed(1) + 's';
            }
            wizzyLog('random', `Auto-poop interval set to ${(poopConfig.autoPoopInterval / 1000).toFixed(1)}s üí©`, '‚è±Ô∏è');
        }
        
        function updatePoopFadeAge() {
            const slider = document.getElementById('poop-fade-age');
            poopConfig.fadeAge = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = (poopConfig.fadeAge / 1000) + 's';
            }
            wizzyLog('random', `Poop lifetime set to ${poopConfig.fadeAge / 1000}s üí©`, '‚åõ');
        }
        
        function updateOwlPoopSize() {
            const slider = document.getElementById('owl-poop-size');
            poopConfig.owlPoopSize = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = poopConfig.owlPoopSize + 'px';
            }
            wizzyLog('random', `Owl poop size set to ${poopConfig.owlPoopSize}px ü¶âüí©`, 'üìè');
        }
        
        function updateMousePoopSize() {
            const slider = document.getElementById('mouse-poop-size');
            poopConfig.mousePoopSize = parseInt(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = poopConfig.mousePoopSize + 'px';
            }
            wizzyLog('random', `Mouse poop size set to ${poopConfig.mousePoopSize}px üê≠üí©`, 'üìè');
        }
        
        function updatePoopGravity() {
            const slider = document.getElementById('poop-gravity');
            poopConfig.owlPoopGravity = parseFloat(slider.value);
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = poopConfig.owlPoopGravity.toFixed(1) + 'x';
            }
            wizzyLog('random', `Owl poop gravity set to ${poopConfig.owlPoopGravity.toFixed(1)}x üéØ‚¨áÔ∏è`, 'ü™Ç');
        }
        
        function updateMaxPoops() {
            const slider = document.getElementById('max-poops');
            const newMax = parseInt(slider.value);
            // Store globally - not in poopConfig
            MAX_POOPS = newMax;
            const label = slider.parentElement.querySelector('.value');
            if (label) {
                label.textContent = newMax;
            }
            wizzyLog('random', `Max poops set to ${newMax} üí©`, 'üóëÔ∏è');
        }

        // Logging controls
        function updateLogDisplay(slider) {
            const value = slider.value;
            const label = slider.parentElement.querySelector('.value');
            
            // Add null check to prevent errors
            if (!label) {
                console.warn('updateLogDisplay: Could not find .value element for slider', slider.id);
                return;
            }
            
            if (slider.id === 'max-log-speed' || slider.id === 'max-log-speed-2') {
                logConfig.maxSpeed = getSpeedMultiplier(value);
                label.textContent = logConfig.maxSpeed.toFixed(1) + 'x';
            } else {
                const type = slider.id.replace('log-', '').replace('-2', '');
                logConfig[type] = parseInt(value);
                label.textContent = value + '%';
            }
        }

        // Console resize state
        let isResizingConsole = false;
        let consoleResizeStart = { x: 0, y: 0, width: 0, height: 0 };
        
        // Console toggle
        function toggleConsole() {
            consoleLog.classList.toggle('active');
            const btn = document.getElementById('console-toggle-btn');
            const btnSmall = document.getElementById('console-btn-small');
            const icon = document.getElementById('console-icon');
            
            if (consoleLog.classList.contains('active')) {
                icon.textContent = 'üôà'; // Monkey covering eyes
                btn.classList.add('active');
                btnSmall.querySelector('span').textContent = 'üôà';
                wizzyLog('random', 'Console opened üìä', 'üíª');
            } else {
                icon.textContent = 'üìã'; // Console icon
                btn.classList.remove('active');
                btnSmall.querySelector('span').textContent = 'üìã';
                wizzyLog('random', 'Console hidden üôà', 'üíª');
            }
        }
        
        // Console resize handlers
        function handleConsoleResizeStart(e) {
            isResizingConsole = true;
            const rect = consoleLog.getBoundingClientRect();
            consoleResizeStart = {
                x: e.clientX,
                y: e.clientY,
                width: rect.width,
                height: rect.height
            };
            e.preventDefault();
        }
        
        function handleConsoleResize(e) {
            if (!isResizingConsole) return;
            
            // Calculate new dimensions (resize from lower left)
            const deltaX = consoleResizeStart.x - e.clientX;
            const deltaY = e.clientY - consoleResizeStart.y;
            
            const newWidth = Math.max(300, Math.min(consoleResizeStart.width + deltaX, window.innerWidth * 0.8));
            const newHeight = Math.max(150, Math.min(consoleResizeStart.height + deltaY, window.innerHeight * 0.8));
            
            // Update console size
            consoleLog.style.width = newWidth + 'px';
            consoleLog.style.height = newHeight + 'px';
            
            // Adjust position to keep upper right corner fixed
            const currentRight = window.innerWidth - (consoleLog.offsetLeft + consoleLog.offsetWidth);
            consoleLog.style.right = currentRight + 'px';
        }
        
        function handleConsoleResizeEnd() {
            isResizingConsole = false;
        }

        // Sound controls
        function toggleSound() {
            soundEnabled = document.getElementById('sound-enabled').checked;
            if (soundEnabled) {
                initAudio();
                wizzyLog('random', 'Sound effects enabled! üîä', 'üéµ');
            } else {
                wizzyLog('random', 'Sound effects disabled üîá', 'üéµ');
            }
        }

        function updateSoundDisplay(slider) {
            const value = slider.value;
            const label = slider.parentElement.querySelector('.value');
            
            // Add null check to prevent errors
            if (!label) {
                console.warn('updateSoundDisplay: Could not find .value element for slider', slider.id);
                return;
            }
            
            label.textContent = value + '%';
            
            const type = slider.id.replace('sound-', '');
            soundConfig[type] = parseInt(value);
        }

        // Update subtitle display
        function updateSubtitle() {
            const subtitle = document.getElementById('main-subtitle');
            const owlText = activeOwlCount === 1 ? '1 Owl' : `${activeOwlCount} Owls`;
            const mouseText = activeMouseCount === 1 ? '1 Mouse' : `${activeMouseCount} Mice`;
            subtitle.textContent = `${owlText} √ó 24 Time Zones √ó ${mouseText}`;
        }

        // Creature count control functions
        function updateActiveOwls() {
            const slider = document.getElementById('active-owls-slider');
            const newCount = parseInt(slider.value);
            const display = document.getElementById('active-owls-display');
            display.textContent = `${newCount} / ${owls.length}`;
            
            // Activate/deactivate owls based on slider
            for (let i = 0; i < owls.length; i++) {
                const wasActive = owls[i].active;
                owls[i].active = i < newCount;
                
                // If deactivating the selected owl, deselect it
                if (wasActive && !owls[i].active && selectedOwl === owls[i]) {
                    selectedOwl = null;
                    updateInfoPanel();
                    wizzyLog('owl', `Deselected ${owls[i].wizzy} as it goes dormant üí§`, 'üîì');
                }
                
                // Log state changes
                if (!wasActive && owls[i].active) {
                    wizzyLog('owl', `${owls[i].wizzy} awakens and joins the hunt! üåÖ`, '‚ú®');
                } else if (wasActive && !owls[i].active) {
                    wizzyLog('owl', `${owls[i].wizzy} goes dormant... üò¥`, 'üåô');
                }
            }
            
            activeOwlCount = newCount;
            updateStats();
            updateSubtitle();
        }
        
        function updateActiveMice() {
            const slider = document.getElementById('active-mice-slider');
            const newCount = parseInt(slider.value);
            const display = document.getElementById('active-mice-display');
            display.textContent = `${newCount} / ${mice.length}`;
            
            // Activate/deactivate mice based on slider
            for (let i = 0; i < mice.length; i++) {
                const wasActive = mice[i].active;
                mice[i].active = i < newCount;
                
                // If deactivating the selected mouse, deselect it
                if (wasActive && !mice[i].active && selectedMouse === mice[i]) {
                    selectedMouse = null;
                    updateInfoPanel();
                    wizzyLog('mouse', `Deselected ${mice[i].wizzy} as it burrows underground üï≥Ô∏è`, 'üîì');
                }
                
                // Log state changes
                if (!wasActive && mice[i].active) {
                    wizzyLog('mouse', `${mice[i].wizzy} emerges from hiding! üå±`, '‚ú®');
                } else if (wasActive && !mice[i].active) {
                    wizzyLog('mouse', `${mice[i].wizzy} burrows underground... üï≥Ô∏è`, 'üí§');
                }
            }
            
            activeMouseCount = newCount;
            updateMouseStats();
            updateSubtitle();
        }
        
        function generateNewOwl() {
            const newId = owls.length + 1;
            const newTimezone = timeZones[Math.floor(Math.random() * timeZones.length)];
            const newOwl = new Owl(newId, newTimezone);
            newOwl.active = true;
            owls.push(newOwl);
            
            // Update slider max and value
            const slider = document.getElementById('active-owls-slider');
            slider.max = owls.length;
            slider.value = owls.length;
            activeOwlCount = owls.length;
            
            // Update display
            updateActiveOwls();
            
            // Select the new owl
            selectedOwl = newOwl;
            selectedMouse = null;
            updateInfoPanel();
            
            wizzyLog('owl', `üé≤ Generated new owl ${newOwl.wizzy} in ${newTimezone}! Total: ${owls.length} ü¶â`, 'üåü');
            playSound('ambient', 0.8);
            updateSubtitle();
        }
        
        function generateNewMouse() {
            const newMouse = new Mouse(mice.length);
            newMouse.active = true;
            mice.push(newMouse);
            
            // Update slider max and value
            const slider = document.getElementById('active-mice-slider');
            slider.max = mice.length;
            slider.value = mice.length;
            activeMouseCount = mice.length;
            
            // Update display
            updateActiveMice();
            
            // Select the new mouse
            selectedMouse = newMouse;
            selectedOwl = null;
            updateInfoPanel();
            
            wizzyLog('mouse', `üé≤ Generated new mouse ${newMouse.wizzy}! Total: ${mice.length} üê≠`, 'üåü');
            playSound('ambient', 0.6);
            updateSubtitle();
        }







        //==============================================================================
        //
        //  MAIN SIMULATION LOOP
        //
        //  This is the new, refactored heart of the application. The old `animate`
        //  function was a monolith; this version delegates tasks to logical helper
        //  functions, making the program flow easy to understand.
        //
        //==============================================================================
        /**
         * The main animation loop, called by requestAnimationFrame.
         * Orchestrates all per-frame updates.
         */
        function animate() {
            const now = Date.now();
            const deltaTime = (now - lastFrameTime) / 1000; // Time since last frame in seconds

            handleViewControls(deltaTime);      // Pan and zoom the camera based on user input.
            
            if (!paused) {
                updateSimulationState(deltaTime, now); // Advance game logic if not paused.
            }
            
            drawMainScene();                    // Render all entities to the main canvas.
            updateUI(now);                      // Update stats, info panels, and the minimap.

            lastFrameTime = now;
            requestAnimationFrame(animate);
        }

        /**
         * Handles all keyboard and mouse inputs that control the camera's pan and zoom.
         * This function runs even when the simulation is paused.
         * @param {number} deltaTime - Time elapsed since the last frame.
         */
        function handleViewControls(deltaTime) {
            // Keyboard Panning
            if (keyboardScrollVelocity.x !== 0 || keyboardScrollVelocity.y !== 0) {
                const panAmount = keyScrollSpeed * deltaTime;
                panOffset.x += keyboardScrollVelocity.x * panAmount / viewScale;
                panOffset.y += keyboardScrollVelocity.y * panAmount / viewScale;
                constrainView();
            }
            
            // Keyboard Zooming
            const zoomSpeed = 1 + (keyZoomSpeed * deltaTime);
            if (keysPressed.has('.') || keysPressed.has('>')) {
                const oldScale = viewScale;
                viewScale *= zoomSpeed;
                constrainView();
                // Zoom towards the center of the screen
                zoomToPoint(canvas.width / 2, canvas.height / 2, oldScale, viewScale);
                constrainView();
            } else if (keysPressed.has(',') || keysPressed.has('<')) {
                const oldScale = viewScale;
                viewScale /= zoomSpeed;
                constrainView();
                // Zoom away from the center of the screen
                zoomToPoint(canvas.width / 2, canvas.height / 2, oldScale, viewScale);
                constrainView();
            }
        }

        /**
         * Advances the state of all game entities (owls, mice, etc.).
         * This function does NOT run when the simulation is paused.
         * @param {number} deltaTime - Time elapsed since the last frame.
         * @param {number} now - The current timestamp from Date.now().
         */
        function updateSimulationState(deltaTime, now) {
            globalTime += deltaTime * TIME_SCALE / 60 * actualSpeedMultiplier;
            frameCount++;

            // Update all entities
            mice.forEach(mouse => mouse.update(mice, owls));
            owls.forEach(owl => owl.update(owls, mice));
            poops.forEach(poop => poop.update());
            foods.forEach(food => food.update());

            // --- Cleanup and State Management ---
            for (let i = foods.length - 1; i >= 0; i--) {
                if (foods[i].age > foods[i].lifespan) foods.splice(i, 1);
            }
            for (let i = poops.length - 1; i >= 0; i--) {
                if (poops[i].age > poops[i].fadeAge) poops.splice(i, 1);
            }
        }

        /**
         * Renders all visual elements to the main canvas.
         */
        function drawMainScene() {
            // Clear the canvas with a trail effect
            ctx.fillStyle = `rgba(0, 0, 0, ${trailsFade})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply the global camera transform
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(viewScale, viewScale);
            ctx.translate(-panOffset.x, -panOffset.y);

            // Draw all the things, poops and food first so they are underneath
            poops.forEach(p => p.draw());
            foods.forEach(f => f.draw());
            mice.forEach(m => m.draw());
            owls.forEach(o => o.draw());

            ctx.restore(); // Revert the camera transform
        }

        /**
         * Updates all non-canvas UI elements like the clock and info panels.
         * @param {number} now - The current timestamp from Date.now().
         */
        function updateUI(now) {
            // Update displays only when not paused
            if (!paused) {
                updateTime();
                if (currentTab === 'owls') updateStats();
                else if (currentTab === 'mice') updateMouseStats();
                else if (currentTab === 'stats') updateGlobalStats();
            }
            
            // Always update info panel for dragging feedback, but throttled
            if (now - lastUpdateTime > 100) {
                updateInfoPanel();
                lastUpdateTime = now;
            }

            // Auto-save every 30 seconds
            if (frameCount > 0 && frameCount % 1800 === 0) { // 30s @ 60fps
                saveState();
            }
            
            // And finally, update the minimap every frame
            updateMinimap();
        }





        // Controls
        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            document.getElementById('pauseBtn').classList.toggle('active', paused);
            wizzyLog('time', paused ? 'Simulation paused ‚è∏Ô∏è' : 'Simulation resumed ‚ñ∂Ô∏è', '‚èØÔ∏è');
        }
        
        function toggleSidebar() {
            const panel = document.getElementById('stats-panel');
            panel.classList.toggle('collapsed');
            if (panel.classList.contains('collapsed')) {
                wizzyLog('random', 'Sidebar collapsed for full screen view üìê', '‚ÜîÔ∏è');
            } else {
                wizzyLog('random', 'Sidebar expanded for InfoVis üìä', '‚ÜîÔ∏è');
            }
        }
        
        function togglePanel() {
            const panel = document.getElementById('stats-panel');
            const toggleBtn = document.getElementById('panel-toggle');
            const arrow = document.getElementById('toggle-arrow');
            
            panel.classList.toggle('panel-hidden');
            toggleBtn.classList.toggle('panel-hidden');
            
            // Toggle arrow direction
            arrow.textContent = panel.classList.contains('panel-hidden') ? '‚ñ∂' : '‚óÄ';
            
            // Log the action
            if (panel.classList.contains('panel-hidden')) {
                wizzyLog('random', 'Stats panel hidden for full view üëÅÔ∏è', '‚ÜîÔ∏è');
            } else {
                wizzyLog('random', 'Stats panel shown üìä', '‚ÜîÔ∏è');
            }
        }

        // Save state to localStorage
        function saveState() {
            const state = {
                version: '1.0',
                timestamp: Date.now(),
                globalTime: globalTime,
                activeOwlCount: activeOwlCount,
                activeMouseCount: activeMouseCount,
                frameCount: frameCount,
                viewScale: viewScale,
                viewOffset: viewOffset,
                owls: owls.map(owl => ({
                    id: owl.id,
                    wizzy: owl.wizzy,
                    timezone: owl.timezone,
                    active: owl.active,
                    position: owl.position,
                    velocity: owl.velocity,
                    energy: owl.energy,
                    catches: owl.catches,
                    attempts: owl.attempts,
                    status: owl.status,
                    colors: owl.colors,
                    middleColorPos: owl.middleColorPos,
                    rotation: owl.rotation,
                    poopCount: owl.poopCount,
                    weight: owl.weight
                })),
                mice: mice.map(mouse => ({
                    id: mouse.id,
                    wizzy: mouse.wizzy,
                    active: mouse.active,
                    position: mouse.position,
                    velocity: mouse.velocity,
                    caught: mouse.caught,
                    caughtBy: mouse.caughtBy,
                    colors: mouse.colors,
                    middleColorPos: mouse.middleColorPos,
                    rotation: mouse.rotation,
                    closeCallCount: mouse.closeCallCount,
                    poopCount: mouse.poopCount,
                    weight: mouse.weight
                })),
                poops: poops.map(poop => ({
                    x: poop.x,
                    y: poop.y,
                    mouseId: poop.mouseId,
                    owlId: poop.owlId,
                    age: poop.age
                })),
                globalStats: globalStats
            };
            
            localStorage.setItem('shneiderman-owls-state', JSON.stringify(state));
            wizzyLog('random', 'Game state saved! üíæ', '‚úÖ');
            
            // Show save indicator
            const indicator = document.getElementById('save-indicator');
            indicator.classList.add('show');
            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }
        
        // Load state from localStorage
        function loadState() {
            const savedState = localStorage.getItem('shneiderman-owls-state');
            if (!savedState) {
                wizzyLog('random', 'No saved state found ü§∑', '‚ùå');
                return false;
            }
            
            try {
                const state = JSON.parse(savedState);
                
                // Restore global variables
                globalTime = state.globalTime || 0;
                activeOwlCount = state.activeOwlCount || 1;
                activeMouseCount = state.activeMouseCount || 1;
                frameCount = state.frameCount || 0;
                viewScale = state.viewScale || 1;
                viewOffset = state.viewOffset || { x: 0, y: 0 };
                
                // Clear and restore owls
                owls.length = 0;
                state.owls.forEach(owlData => {
                    const owl = new Owl(owlData.id, owlData.timezone);
                    Object.assign(owl, owlData);
                    owls.push(owl);
                });
                
                // Clear and restore mice
                mice.length = 0;
                state.mice.forEach(mouseData => {
                    const mouse = new Mouse(mice.length);
                    Object.assign(mouse, mouseData);
                    mice.push(mouse);
                });
                
                // Clear and restore poops
                poops.length = 0;
                state.poops.forEach(poopData => {
                    const poop = new Poop(poopData.x, poopData.y, poopData.mouseId, poopData.owlId);
                    poop.age = poopData.age;
                    poops.push(poop);
                });
                
                // Restore global stats
                Object.assign(globalStats, state.globalStats);
                
                // Update UI elements
                document.getElementById('active-owls-slider').value = activeOwlCount;
                document.getElementById('active-owls-slider').max = owls.length;
                document.getElementById('active-mice-slider').value = activeMouseCount;
                document.getElementById('active-mice-slider').max = mice.length;
                updateActiveOwls();
                updateActiveMice();
                
                wizzyLog('random', `Game state loaded! Day ${Math.floor(globalTime / (24 * 60)) + 1} üéÆ`, '‚úÖ');
                return true;
            } catch (error) {
                console.error('Failed to load state:', error);
                wizzyLog('random', 'Failed to load saved state üòï', '‚ùå');
                return false;
            }
        }

        function resetSimulation() {
            // Confirm reset
            if (!confirm('Are you sure you want to reset the simulation? This will clear all progress and start fresh.')) {
                wizzyLog('random', 'Reset cancelled - phew! üòÖ', 'üõ°Ô∏è');
                return;
            }
            
            globalTime = 0;
            selectedOwl = null;
            selectedMouse = null;
            updateInfoPanel();
            frameCount = 0;
            
            // Clear all poops
            poops.length = 0;
            
            // Reset global stats
            globalStats.totalHunts = 0;
            globalStats.successfulHunts = 0;
            globalStats.closeCalls = 0;
            globalStats.hourlyHunts = new Array(24).fill(0);
            
            // Reset to initial active counts
            activeOwlCount = 1;
            activeMouseCount = 1;
            document.getElementById('active-owls-slider').value = 1;
            document.getElementById('active-mice-slider').value = 1;
            updateActiveOwls();
            updateActiveMice();
            
            // Reset owls
            owls.forEach((owl, i) => {
                owl.position = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    z: 50 + Math.random() * 100
                };
                owl.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: 0
                };
                owl.energy = 100;
                owl.catches = 0;
                owl.attempts = 0;
                owl.status = 'flying';
                owl.target = null;
            });

            // Reset mice
            mice.forEach(mouse => {
                mouse.position = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
                mouse.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                mouse.caught = false;
                mouse.caughtBy = null;
                mouse.closeCallCount = 0;
                mouse.poopCount = 0;
                mouse.lastPoopTime = 0;
            });
            
            wizzyLog('time', 'Simulation reset! Everything starts fresh üåÖ', 'üîÑ');
        }

        // Initialize controls
        updateSpeedDisplay();
        updateMagnetDisplay();
        updateZoomDisplay();
        updateKeyScrollDisplay();
        updateKeyZoomDisplay();
        updateTrailsDisplay();
        updateMagnetStrength();
        updateMagnetNeutralZone();
        updateMinimapSizes();
        
        // Global wizzy button click handler with AGGRESSIVE debugging
        document.addEventListener('click', (e) => {
            // ALWAYS log every click for debugging
            console.warn('üî¥ CLICK EVENT:', {
                target: e.target,
                tagName: e.target.tagName,
                className: e.target.className,
                classList: [...e.target.classList],
                dataset: e.target.dataset,
                parentElement: e.target.parentElement,
                textContent: e.target.textContent
            });
            
            // Check if it's a wizzy button or its parent
            let wizzyTarget = null;
            if (e.target.classList.contains('wizzy-button')) {
                wizzyTarget = e.target;
                console.warn('üü¢ DIRECT WIZZY CLICK!');
            } else if (e.target.classList.contains('col-wizzy')) {
                wizzyTarget = e.target;
                console.warn('üü° CLICKED COL-WIZZY!');
            } else if (e.target.closest('.wizzy-button')) {
                wizzyTarget = e.target.closest('.wizzy-button');
                console.warn('üü† FOUND WIZZY PARENT!');
            } else if (e.target.closest('.col-wizzy')) {
                wizzyTarget = e.target.closest('.col-wizzy');
                console.warn('üü§ FOUND COL-WIZZY PARENT!');
            }
            
            if (wizzyTarget) {
                console.warn('üéØ WIZZY TARGET FOUND:', wizzyTarget);
                wizzyLog('wizzyClick', `WIZZY CLICKED: ${wizzyTarget.textContent}`, 'üñ±Ô∏è');
                
                // Make sure we have owls and mice arrays
                if (typeof owls === 'undefined' || typeof mice === 'undefined') {
                    console.error('‚ùå Owls or mice arrays not defined yet!');
                    wizzyLog('wizzyClick', 'ERROR: Arrays not defined!', '‚ùå');
                    return;
                }
                
                e.stopPropagation();
                e.preventDefault();
                
                // Handle owl selection
                if (wizzyTarget.dataset.owlId) {
                    const owlId = parseInt(wizzyTarget.dataset.owlId);
                    console.warn('ü¶â OWL ID:', owlId);
                    wizzyLog('wizzyClick', `Trying to select owl ID: ${owlId}`, 'ü¶â');
                    
                    const owl = owls.find(o => o.id === owlId);
                    if (owl) {
                        console.warn('‚úÖ OWL FOUND:', owl);
                        selectedOwl = selectedOwl === owl ? null : owl;
                        selectedMouse = null;
                        updateInfoPanel();
                        updateStats();
                        updateMinimap();
                        wizzyLog('owl', selectedOwl ? `Selected ${owl.wizzy} üéØ` : `Deselected ${owl.wizzy} ‚ùå`, 'üëÜ');
                        wizzyLog('wizzyClick', selectedOwl ? `OWL SELECTED: ${owl.wizzy}` : `OWL DESELECTED: ${owl.wizzy}`, '‚úÖ');
                        playSound('select', 0.5);
                        
                        // Center view on selected owl ONLY when selecting (not deselecting)
                        if (selectedOwl && selectedOwl === owl) {
                            const pos = selectedOwl.getScreenPosition();
                            centerViewOn(pos.x, pos.y);
                        }
                        
                        if (currentTab === 'owls' && selectedOwl) {
                            scrollToTableRow(owl.id, 'owl');
                        }
                    } else {
                        console.error('‚ùå OWL NOT FOUND WITH ID:', owlId);
                        wizzyLog('wizzyClick', `ERROR: Owl ${owlId} not found!`, '‚ùå');
                    }
                } 
                // Handle mouse selection
                else if (wizzyTarget.dataset.mouseId) {
                    const mouseId = wizzyTarget.dataset.mouseId;
                    console.warn('üê≠ MOUSE ID:', mouseId, 'Type:', typeof mouseId);
                    wizzyLog('wizzyClick', `Trying to select mouse ID: ${mouseId}`, 'üê≠');
                    
                    const mouse = mice.find(m => m.id === mouseId || String(m.id) === mouseId);
                    if (mouse) {
                        console.warn('‚úÖ MOUSE FOUND:', mouse);
                        selectedMouse = selectedMouse === mouse ? null : mouse;
                        selectedOwl = null;
                        updateInfoPanel();
                        updateMouseStats();
                        updateMinimap();
                        wizzyLog('mouse', selectedMouse ? `Selected ${mouse.wizzy} üéØ` : `Deselected ${mouse.wizzy} ‚ùå`, 'üëÜ');
                        wizzyLog('wizzyClick', selectedMouse ? `MOUSE SELECTED: ${mouse.wizzy}` : `MOUSE DESELECTED: ${mouse.wizzy}`, '‚úÖ');
                        playSound('select', 0.5);
                        
                        // Center view on selected mouse ONLY when selecting (not deselecting)
                        if (selectedMouse && selectedMouse === mouse) {
                            centerViewOn(selectedMouse.position.x, selectedMouse.position.y);
                        }
                        
                        if (currentTab === 'mice' && selectedMouse) {
                            scrollToTableRow(mouse.id, 'mouse');
                        }
                    } else {
                        console.error('‚ùå MOUSE NOT FOUND WITH ID:', mouseId);
                        wizzyLog('wizzyClick', `ERROR: Mouse ${mouseId} not found!`, '‚ùå');
                    }
                }
            }
        }, true); // Use capture phase

        // Initialize logging controls
        document.querySelectorAll('.log-control input').forEach(slider => {
            updateLogDisplay(slider);
        });
        
        // Set up console resize handlers
        const consoleResize = document.getElementById('console-resize');
        if (consoleResize) {
            consoleResize.addEventListener('mousedown', handleConsoleResizeStart);
        }
        document.addEventListener('mousemove', handleConsoleResize);
        document.addEventListener('mouseup', handleConsoleResizeEnd);

        // Start animation
        animate();
        
        // Initial stats update
        updateStats();
        updateMouseStats();
        updateGlobalStats();
        
        // Set up table event handlers after DOM is ready
        setTimeout(() => {
            const statsPanel = document.getElementById('stats-panel');
            console.log('Setting up table handlers, stats panel:', statsPanel);
            if (statsPanel) {
                // Mousedown handler for draggable elements
                statsPanel.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('timezone')) {
                        handleTableMouseDown(e);
                    } else if (e.target.classList.contains('owl-energy')) {
                        handleEnergyDragStart(e);
                    } else if (e.target.classList.contains('owl-altitude')) {
                        handleAltitudeDragStart(e);
                    } else if (e.target.classList.contains('wizzy-button') || e.target.classList.contains('col-wizzy')) {
                        // WIZZY BUTTON CLICK TEST
                        console.warn('üí• WIZZY CLICKED IN MOUSEDOWN:', e.target);
                        e.preventDefault();
                        
                        const owlId = e.target.dataset.owlId;
                        const mouseId = e.target.dataset.mouseId;
                        
                        if (owlId) {
                            console.warn('ü¶â SELECTING OWL:', owlId);
                            const owl = owls.find(o => o.id === parseInt(owlId));
                            if (owl) {
                                selectedOwl = selectedOwl === owl ? null : owl;
                                selectedMouse = null;
                                updateInfoPanel();
                                updateStats();
                                updateMinimap();
                                playSound('select', 0.5);
                                wizzyLog('owl', selectedOwl ? `Selected ${owl.wizzy} via table üéØ` : `Deselected ${owl.wizzy} ‚ùå`, 'üëÜ');
                                
                                // Center view on selected owl ONLY when selecting
                                if (selectedOwl && selectedOwl === owl) {
                                    centerViewOn(selectedOwl.position.x, selectedOwl.position.y);
                                }
                            }
                        } else if (mouseId) {
                            console.warn('üê≠ SELECTING MOUSE:', mouseId);
                            const mouse = mice.find(m => m.id === mouseId || String(m.id) === mouseId);
                            if (mouse) {
                                selectedMouse = selectedMouse === mouse ? null : mouse;
                                selectedOwl = null;
                                updateInfoPanel();
                                updateMouseStats();
                                updateMinimap();
                                playSound('select', 0.5);
                                wizzyLog('mouse', selectedMouse ? `Selected ${mouse.wizzy} via table üéØ` : `Deselected ${mouse.wizzy} ‚ùå`, 'üëÜ');
                                
                                // Center view on selected mouse ONLY when selecting
                                if (selectedMouse && selectedMouse === mouse) {
                                    centerViewOn(selectedMouse.position.x, selectedMouse.position.y);
                                }
                            }
                        }
                    }
                });
                
                // Status toggle on click (capture phase to handle before row click)
                statsPanel.addEventListener('click', (e) => {
                    if (e.target.classList.contains('owl-status')) {
                        e.stopPropagation(); // Don't trigger row selection
                        const owlId = parseInt(e.target.dataset.owlId);
                        const owl = owls.find(o => o.id === owlId);
                        if (owl) {
                            // Toggle between hunting and resting
                            owl.status = owl.status === 'hunting' ? 'resting' : 
                                        owl.status === 'resting' ? 'flying' : 'hunting';
                            updateStats();
                            wizzyLog('owl', `${owl.wizzy} status changed to ${owl.status} üîÑ`, '‚ö°');
                        }
                    }
                }, true); // Use capture to handle before row click
                
                // Wizzy button click handler - FIXED TO WORK PROPERLY!
                statsPanel.addEventListener('click', (e) => {
                    console.log('Click event on:', e.target, 'Classes:', e.target.classList);
                    
                    // Check if we clicked on a wizzy button or something inside it
                    const wizzyButton = e.target.classList.contains('wizzy-button') ? e.target : e.target.closest('.wizzy-button');
                    
                    if (wizzyButton) {
                        console.log('Wizzy button clicked!', wizzyButton);
                        e.stopPropagation(); // Don't trigger other handlers
                        e.preventDefault(); // Prevent any default behavior
                        
                        // Handle owl selection
                        if (wizzyButton.dataset.owlId) {
                            const owlId = parseInt(wizzyButton.dataset.owlId);
                            console.log('Looking for owl with ID:', owlId);
                            const owl = owls.find(o => o.id === owlId);
                            if (owl) {
                                console.log('Found owl:', owl);
                                selectedOwl = selectedOwl === owl ? null : owl;
                                selectedMouse = null;
                                updateInfoPanel();
                                updateStats();
                                wizzyLog('owl', selectedOwl ? `Selected ${owl.wizzy} üéØ` : `Deselected ${owl.wizzy} ‚ùå`, 'üëÜ');
                                playSound('select', 0.5);
                                
                                // Center view on selected owl ONLY when selecting
                                if (selectedOwl && selectedOwl === owl) {
                                    centerViewOn(selectedOwl.position.x, selectedOwl.position.y);
                                }
                                
                                // Scroll to owl in table if owls tab is active
                                if (currentTab === 'owls' && selectedOwl) {
                                    scrollToTableRow(owl.id, 'owl');
                                }
                            } else {
                                console.error('Owl not found with ID:', owlId);
                            }
                        } 
                        // Handle mouse selection
                        else if (wizzyButton.dataset.mouseId) {
                            const mouseId = wizzyButton.dataset.mouseId;
                            console.log('Looking for mouse with ID:', mouseId, 'Type:', typeof mouseId);
                            // Mouse IDs are strings, not numbers!
                            const mouse = mice.find(m => m.id === mouseId || m.id === parseInt(mouseId) || String(m.id) === mouseId);
                            if (mouse) {
                                console.log('Found mouse:', mouse);
                                selectedMouse = selectedMouse === mouse ? null : mouse;
                                selectedOwl = null;
                                updateInfoPanel();
                                updateMouseStats();
                                wizzyLog('mouse', selectedMouse ? `Selected ${mouse.wizzy} üéØ` : `Deselected ${mouse.wizzy} ‚ùå`, 'üëÜ');
                                playSound('select', 0.5);
                                
                                // Center view on selected mouse ONLY when selecting
                                if (selectedMouse && selectedMouse === mouse) {
                                    centerViewOn(selectedMouse.position.x, selectedMouse.position.y);
                                }
                                
                                // Scroll to mouse in table if mice tab is active
                                if (currentTab === 'mice' && selectedMouse) {
                                    scrollToTableRow(mouse.id, 'mouse');
                                }
                            } else {
                                console.error('Mouse not found with ID:', mouseId, 'All mouse IDs:', mice.map(m => ({id: m.id, type: typeof m.id})));
                            }
                        }
                    }
                }, false); // Use bubbling phase
            }
        }, 100);
        
        // Helper function to scroll to a table row
        function scrollToTableRow(entityId, type) {
            const tableId = type === 'owl' ? 'owl-stats' : 'mouse-stats';
            const tbody = document.getElementById(tableId);
            if (!tbody) return;
            
            const row = tbody.querySelector(`tr[data-${type}-id="${entityId}"]`);
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        
        // Show help screen
        function showHelpScreen() {
            const helpHTML = `
                <div id="help-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif;">
                    <div style="background: #1a1a1a; border: 2px solid #4a9eff; border-radius: 10px; padding: 30px; max-width: 800px; max-height: 80vh; overflow-y: auto; box-shadow: 0 0 30px rgba(74,158,255,0.5);">
                        <h2 style="color: #4a9eff; margin-top: 0;">ü¶â Shneiderman's Owls: Wizzy Edition - Help ü¶â</h2>
                        
                        <h3 style="color: #ffa500;">üéÆ Controls</h3>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin-bottom: 20px;">
                            <span style="color: #66ff66;">Tab</span><span style="color: #ccc;">Toggle UI (zen mode)</span>
                            <span style="color: #66ff66;">Space</span><span style="color: #ccc;">Pause/Resume simulation</span>
                            <span style="color: #66ff66;">WASD</span><span style="color: #ccc;">Scroll view</span>
                            <span style="color: #66ff66;">Arrow Keys</span><span style="color: #ccc;">Manual creature control: ‚Üë speed up, ‚Üì slow down, ‚Üê turn left, ‚Üí turn right</span>
                            <span style="color: #66ff66;">Period (.)</span><span style="color: #ccc;">Stop selected creature (also zooms in when no creature selected)</span>
                            <span style="color: #66ff66;">/ and '</span><span style="color: #ccc;">Owl altitude control: / descend, ' ascend</span>
                            <span style="color: #66ff66;">\\</span><span style="color: #ccc;">Cycle creature mode (droning/flying/hunting/resting for owls, droning/foraging/fleeing for mice)</span>
                            <span style="color: #66ff66;">Escape</span><span style="color: #ccc;">Deselect creature and release manual control</span>
                            <span style="color: #66ff66;">Comma (,)</span><span style="color: #ccc;">Zoom out (keyboard zoom centers on view)</span>
                            <span style="color: #66ff66;">0</span><span style="color: #ccc;">Reset zoom and pan</span>
                            <span style="color: #66ff66;">Ctrl/Cmd+S</span><span style="color: #ccc;">Save game state</span>
                            <span style="color: #66ff66;">Ctrl/Cmd+L</span><span style="color: #ccc;">Load saved game</span>
                            <span style="color: #66ff66;">?</span><span style="color: #ccc;">Show this help</span>
                        </div>
                        
                        <h3 style="color: #ffa500;">üñ±Ô∏è Mouse Actions</h3>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin-bottom: 20px;">
                            <span style="color: #66ff66;">Left Click</span><span style="color: #ccc;">Select owl/mouse or activate mouse magnet</span>
                            <span style="color: #66ff66;">Right Click</span><span style="color: #ccc;">Pan view</span>
                            <span style="color: #66ff66;">Scroll Wheel</span><span style="color: #ccc;">Zoom in/out</span>
                            <span style="color: #66ff66;">Drag Owl/Mouse</span><span style="color: #ccc;">Move creatures around</span>
                            <span style="color: #66ff66;">Drag Near Edge</span><span style="color: #ccc;">Auto-scroll view</span>
                        </div>
                        
                        <h3 style="color: #ffa500;">üéÆ Manual Control</h3>
                        <p style="color: #ccc;"><strong>Droning Mode:</strong> Selected creatures auto-enter droning mode (thick cyan dashed circle).
                        In droning mode, they ignore ALL autonomous behaviors. Use \\ to cycle between modes.<br>
                        <strong>Temporary Override:</strong> In non-droning modes, holding control keys temporarily overrides AI
                        (thin cyan circle). Release keys and the creature resumes its normal behavior.<br>
                        <strong>Controls:</strong> ‚Üë accelerates forward, ‚Üì brakes (not reverse!), ‚Üê ‚Üí turn and steer. Press . to stop instantly.</p>
                        
                        <h3 style="color: #ffa500;">üß≤ Mouse Magnet</h3>
                        <p style="color: #ccc;">Click empty space to activate. Adjust radius and strength in controls. 
                        Positive values attract mice, negative values repel them. Inner dashed circle shows neutral zone.</p>
                        
                                                    <h3 style="color: #ffa500;">üéöÔ∏è Creature Control</h3>
                        <p style="color: #ccc;">Use the sliders at the top of Owls/Mice tabs to control how many are active.
                        Start with 1v1 for easy observation, then gradually increase complexity. Inactive creatures are 
                        "sleeping" and can be reawakened. If you hide a selected creature, it auto-deselects. 
                        Game state auto-saves when you leave!</p>
                        
                        <h3 style="color: #ffa500;">üìä Stats Panel</h3>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin-bottom: 20px;">
                            <span style="color: #66ff66;">Click WIZZY</span><span style="color: #ccc;">Select creature (golden buttons)</span>
                            <span style="color: #66ff66;">Drag Timezone</span><span style="color: #ccc;">Change owl's timezone</span>
                            <span style="color: #66ff66;">Click/Drag Energy</span><span style="color: #ccc;">Set owl's energy level directly</span>
                            <span style="color: #66ff66;">Drag Altitude</span><span style="color: #ccc;">Change owl's flying height</span>
                            <span style="color: #66ff66;">Click Status</span><span style="color: #ccc;">Toggle hunting/resting/flying</span>
                        </div>
                        
                        <p style="color: #888; text-align: center; margin-top: 30px;">Press any key to close</p>
                    </div>
                </div>
            `;
            
            const helpDiv = document.createElement('div');
            helpDiv.innerHTML = helpHTML;
            document.body.appendChild(helpDiv);
            
            // Close on any key press
            const closeHelp = (e) => {
                e.preventDefault();
                document.body.removeChild(helpDiv);
                document.removeEventListener('keydown', closeHelp);
            };
            document.addEventListener('keydown', closeHelp);
            
            wizzyLog('random', 'Help screen displayed üìñ', '‚ùì');
        }
        
        // Auto-save on page unload
        window.addEventListener('beforeunload', () => {
            saveState();
        });
        
        // Try to load saved state on startup
        setTimeout(() => {
            if (localStorage.getItem('shneiderman-owls-state')) {
                wizzyLog('random', 'Found saved game! Use Ctrl/Cmd+L to load it üíæ', 'üìÇ');
            }
        }, 1000);
        
        // Welcome message
        wizzyLog('time', 'Welcome to Shneiderman\'s Owls: Wizzy Edition! ü¶â‚ú®', 'üéâ');
    </script>
</body>
</html>
